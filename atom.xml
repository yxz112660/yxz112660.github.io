<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YXZ的博客</title>
  
  <subtitle>好好努力,天天向上</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yangxiaozong.com/"/>
  <updated>2019-09-17T12:32:31.219Z</updated>
  <id>http://www.yangxiaozong.com/</id>
  
  <author>
    <name>YXZ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>View绘制过程</title>
    <link href="http://www.yangxiaozong.com/View%E7%BB%98%E5%88%B6%E8%BF%87%E7%A8%8B.html"/>
    <id>http://www.yangxiaozong.com/View绘制过程.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.219Z</updated>
    
    <content type="html"><![CDATA[<p>整个View树的绘图流程是在ViewRootImpl类的performTraversals()方法（这个方法巨长）开始的，该函数做的执行过程主要是根据之前设置的状态，判断是否重新计算视图大小(measure)、是否重新放置视图的位置(layout)、以及是否重绘 (draw)。</p><p><img src="images/draw_1.jpg" alt=""></p><h2 id="Measure"><a href="#Measure" class="headerlink" title="Measure"></a>Measure</h2><a id="more"></a><p><img src="images/draw_2.jpg" alt=""></p><p>通过上面可以看出measure过程主要就是从顶层父View向子View递归调用<code>view.measure</code>方法（measure中又回调onMeasure方法）的过程。具体measure核心主要有如下几点：</p><ul><li><p><code>MeasureSpec</code>（View的内部类）测量规格为int型，值由高2位规格模式<code>specMode</code>和低30位具体尺寸<code>specSize</code>组成。其中specMode只有三种值：</p><ul><li><code>MeasureSpec.EXACTLY</code> //确定模式，父View希望子View的大小是确定的，由specSize决定；</li><li><code>MeasureSpec.AT_MOST</code> //最多模式，父View希望子View的大小最多是specSize指定的值；</li><li><code>MeasureSpec.UNSPECIFIED</code> //未指定模式，父View完全依据子View的设计值来决定；</li></ul></li><li><p>View的 measure 方法是<code>final</code>的，不允许重载，<strong>View子类只能重载onMeasure来完成自己的测量逻辑</strong>。</p></li><li><p>最顶层DecorView测量时的MeasureSpec是由ViewRootImpl中getRootMeasureSpec方法确定的，<strong>LayoutParams宽高参数均为MATCH_PARENT，specMode是EXACTLY，specSize为物理屏幕大小</strong>。</p></li><li><p>ViewGroup类提供了<code>measureChild</code>，<code>measureChild</code>和<code>measureChildWithMargins</code>方法，简化了父子View的尺寸计算。</p></li><li><p>只要是ViewGroup的子类就必须要求LayoutParams继承子MarginLayoutParams，否则无法使用layout_margin参数。</p></li><li><p>View的布局大小由父View和子View共同决定。</p></li><li><p>使用View的<code>getMeasuredWidth()</code>和<code>getMeasuredHeight()</code>方法来获取View测量的宽高，必须保证这两个方法在<code>onMeasure</code>流程之后被调用才能返回有效值。</p></li></ul><h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><p><img src="images/draw_3.jpg" alt=""></p><p>layout方法接收四个参数，这四个参数分别代表相对Parent的左、上、右、下坐标。而且还可以看见左上都为0，右下分别为上面刚刚测量的width和height。</p><p>整个layout过程比较容易理解，从上面分析可以看出layout也是从顶层父View向子View的递归调用view.layout方法的过程，即父View根据上一步measure子View所得到的布局大小和布局参数，将子View放在合适的位置上。具体layout核心主要有以下几点：</p><ul><li><p><code>View.layout</code>方法可被重载，<code>ViewGroup.layout</code>为final的不可重载，<code>ViewGroup.onLayout</code>为abstract的，子类必须重载实现自己的位置逻辑。</p></li><li><p>measure操作完成后得到的是对每个View经测量过的<code>measuredWidth</code>和<code>measuredHeight</code>，layout操作完成之后得到的是对每个View进行位置分配后的mLeft、mTop、mRight、mBottom，这些值都是相对于父View来说的。</p></li><li><p><strong>凡是layout_XXX的布局属性基本都针对的是包含子View的ViewGroup的，当对一个没有父容器的View设置相关layout_XXX属性是没有任何意义的</strong>。</p></li><li><p>使用View的getWidth()和getHeight()方法来获取View测量的宽高，必须保证这两个方法在onLayout流程之后被调用才能返回有效值。</p></li></ul><h2 id="Draw"><a href="#Draw" class="headerlink" title="Draw"></a>Draw</h2><p><img src="images/draw_4.jpg" alt=""></p><p>ViewRootImpl中的代码会创建一个Canvas对象，然后调用View的draw()方法来执行具体的绘制工作。</p><p>可以看见，绘制过程就是把View对象绘制到屏幕上，整个draw过程需要注意如下细节：</p><ul><li><p>如果该View是一个<code>ViewGroup</code>，则需要递归绘制其所包含的所有子View。</p></li><li><p>View默认不会绘制任何内容，真正的绘制都需要自己在子类中实现。</p></li><li><p>View的绘制是借助<code>onDraw</code>方法传入的<code>Canvas</code>类来进行的。</p></li><li><p>区分View动画和ViewGroup布局动画，前者指的是View自身的动画，可以通过<code>setAnimation</code>添加，后者是专门针对<code>ViewGroup</code>显示内部子视图时设置的动画，可以在xml布局文件中对<code>ViewGroup</code>设置<code>layoutAnimation</code>属性。</p></li><li><p>在获取画布剪切区（每个<code>View</code>的<code>draw</code>中传入的<code>Canvas</code>）时会自动处理掉<code>padding</code>，子<code>View</code>获取<code>Canvas</code>不用关注这些逻辑，只用关心如何绘制即可。</p></li><li><p>默认情况下子<code>View</code>的<code>ViewGroup.drawChild</code>绘制顺序和子<code>View</code>被添加的顺序一致，但是你也可以重载<code>ViewGroup.getChildDrawingOrder()</code>方法提供不同顺序。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;整个View树的绘图流程是在ViewRootImpl类的performTraversals()方法（这个方法巨长）开始的，该函数做的执行过程主要是根据之前设置的状态，判断是否重新计算视图大小(measure)、是否重新放置视图的位置(layout)、以及是否重绘 (draw)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/draw_1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Measure&quot;&gt;&lt;a href=&quot;#Measure&quot; class=&quot;headerlink&quot; title=&quot;Measure&quot;&gt;&lt;/a&gt;Measure&lt;/h2&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="View" scheme="http://www.yangxiaozong.com/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Activity、View及Window之间关系</title>
    <link href="http://www.yangxiaozong.com/Activity%E3%80%81View%E5%8F%8AWindow%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB.html"/>
    <id>http://www.yangxiaozong.com/Activity、View及Window之间关系.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:30:31.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><p>View（包括ViewGroup）使用的是组合模式，将View组成成树形结构，以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。View主要是用于绘制我们想要的结果，是一个最基本的UI组件。</p><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p>简单地说，<code>Window</code>表示一个窗口，一般来说，<code>Window</code>大小取值为屏幕大小。但是这不是绝对的，如对话框、Toast等就不是整个屏幕大小。你可以指定<code>Window</code>的大小。<code>Window</code>包含一个<code>View tree</code>和窗口的<code>layout</code>参数。</p><p>感觉Window的理解比较抽象，Window相当于一个容器，里面“盛放”着很多View，这些View是以树状结构组织起来的。<br><a id="more"></a></p><blockquote><p>如果还是无法理解的话，就把Window当成是显示器，显示器有大有小（对应Window有大有小），View是显示器里面具体显示的内容。</p></blockquote><h3 id="Window对象存在的必要性"><a href="#Window对象存在的必要性" class="headerlink" title="Window对象存在的必要性"></a>Window对象存在的必要性</h3><p><code>Window</code>能做的事情，<code>View</code>对象基本都能做：像什么触摸事件啊、显示的坐标及大小啊、管理各个子View啊等等。View已经这么强大了，为什么还多此一举，加个<code>Window</code>对象。可能有人会说因为<code>WindowManager</code>管理的就是<code>Window</code>对象呀，那我想问，既然这样，Android系统直接让<code>WindowManager</code>去管理<code>View</code>不就好了？让View接替<code>Window</code>的工作，把<code>Window</code>所做的事情都封装到<code>View</code>里面不好嘛？。或许又有人说，<code>View</code>负责绘制显示内容，<code>Window</code>负责管理<code>View</code>，各自的工作职责不同。可是我想说，<code>Window</code>所做的大部分工作，<code>View</code>里面都有同样（或类似）的处理。</p><p>关于<code>Window</code>存在的必要，我查了国内外各种资料，最后有了我个人的理解。在后面小节里面，我会结合我个人的理解来解释。在解释之前，我们需要了解Window绘制过程。</p><h3 id="Window绘制过程"><a href="#Window绘制过程" class="headerlink" title="Window绘制过程"></a>Window绘制过程</h3><p>在理解<code>Window</code>绘制过程之前，首先，我们需要知道<code>Surface</code>，在<code>Window</code>中持有一个<code>Surface</code>，那么什么是<code>Surface</code>呢？</p><p><code>Surface</code>其实就是一个持有像素点矩阵的对象，这个像素点矩阵是组成显示在屏幕的图像的一部分。<strong>我们看到显示的每个Window（包括对话框、全屏的Activity、状态栏等）都有他自己绘制的<code>Surface</code></strong>。而最终的显示可能存在<code>Window</code>之间遮挡的问题，此时就是通过<code>Surface Flinger对</code>象渲染最终的显示，使他们以正确的<code>Z-order</code>显示出来。一般<code>Surface</code>拥有一个或多个缓存（一般2个），通过双缓存来刷新，这样就可以一边绘制一边加新缓存。</p><p><code>WindowManager</code>为每个<code>Window</code>创建<code>Surface</code>对象，然后应用就可以通过这个<code>Surface</code>来绘制任何它想要绘制的东西。而对于<code>WindowManager</code>来说，这只不过是一块矩形区域而已。</p><p>前面我们说过，<code>View</code>是<code>Window</code>里面用于交互的UI元素。<code>Window</code>只attach一个<code>View Tree</code>，当<code>Window</code>需要重绘（如，当View调用<code>invalidate</code>）时，最终转为<code>Window</code>的<code>Surface</code>，<code>Surface</code>被锁住（locked）并返回Canvas对象，此时View拿到Canvas对象来绘制自己。当所有View绘制完成后，<code>Surface</code>解锁（unlock），并且post到绘制缓存用于绘制，通过<code>Surface Flinger</code>来组织各个Window，显示最终的整个屏幕。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们知道了<code>Window</code>绘制过程，其实，站在系统的角度来考虑，一个Window对象代表一块显示区域，系统不关心Window里面具体的绘制内容，也不管你<code>Window</code>怎么去绘制，反正只给你提供可以在这块区域上绘制图形的<code>Surface</code>对象，你<code>Window</code>对象怎么画是你的事情！</p><p>换句话说，站在系统的角度上看，系统是“不知道”有View对象这个说法的！作为系统，我有自己的骄傲，不去管你Window如何搬砖、如何砌墙，只给你地皮。而这时，Window为了绘制出用户想要的组件（按钮、文字、输入框等等），系统又不给我！没事，那我自己定义，于是就定义了View机制，给每个View提供Canvas，让不同的View自己绘制具有自己特色的组件。同时，为了更好的管理View，通过定义ViewGroup，等等。</p><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>对于开发人员来说，一个<code>Activity</code>就“相当于”一个界面（通过<code>setContentView</code>指定具体的View）。我们可以直接在Activity里处理事件，如<code>onKeyEvent</code>,<code>onTouchEvent</code>等。 并可以通过Activity维护应用程序的生命周期。</p><h3 id="Activity和Window"><a href="#Activity和Window" class="headerlink" title="Activity和Window"></a>Activity和Window</h3><p>前面我们知道，<code>Window</code>已经是系统管理的窗口界面。那么为什么还需要<code>Activity</code>呢？我们把<code>Activity</code>所做的事情，全部封装到<code>Window</code>不就好了？</p><p>其实，本质上讲，我们要显示一个窗口出来，的确可以不需要Activity。悬浮窗口中不就是没有使用Activity来显示一个悬浮窗吗？既然如此，Window（以及View）能处理点击事件以及封装各种逻辑，那为啥还需要Activity呢？</p><p><code>Android</code>中的应用中，里面对各个窗口的管理相当复杂（任务栈、状态等等），Android系统当然可以不用Activity，让用户自己直接操作Window来开发自己的应用。但是如果让用户自己去管理这些Window，先不说工作量，光让用户自己去实现任务栈这点，有几个人能写的出来。<strong>为了让大家能简单、快速的开发应用，Android通过定义Activity，让Activity帮我们管理好，我们只需简单的去重写几个回调函数，无需直接与Window对象接触</strong>。各种事件也只需重写Activity里面的回调即可。无需关注其他细节，默认都帮我们写好了，针对需要定制的部分我们重写（设计模式为：模板方法模式）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;View&quot;&gt;&lt;a href=&quot;#View&quot; class=&quot;headerlink&quot; title=&quot;View&quot;&gt;&lt;/a&gt;View&lt;/h2&gt;&lt;p&gt;View（包括ViewGroup）使用的是组合模式，将View组成成树形结构，以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。View主要是用于绘制我们想要的结果，是一个最基本的UI组件。&lt;/p&gt;
&lt;h2 id=&quot;Window&quot;&gt;&lt;a href=&quot;#Window&quot; class=&quot;headerlink&quot; title=&quot;Window&quot;&gt;&lt;/a&gt;Window&lt;/h2&gt;&lt;p&gt;简单地说，&lt;code&gt;Window&lt;/code&gt;表示一个窗口，一般来说，&lt;code&gt;Window&lt;/code&gt;大小取值为屏幕大小。但是这不是绝对的，如对话框、Toast等就不是整个屏幕大小。你可以指定&lt;code&gt;Window&lt;/code&gt;的大小。&lt;code&gt;Window&lt;/code&gt;包含一个&lt;code&gt;View tree&lt;/code&gt;和窗口的&lt;code&gt;layout&lt;/code&gt;参数。&lt;/p&gt;
&lt;p&gt;感觉Window的理解比较抽象，Window相当于一个容器，里面“盛放”着很多View，这些View是以树状结构组织起来的。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="Activity" scheme="http://www.yangxiaozong.com/tags/Activity/"/>
    
      <category term="View" scheme="http://www.yangxiaozong.com/tags/View/"/>
    
      <category term="Window" scheme="http://www.yangxiaozong.com/tags/Window/"/>
    
  </entry>
  
  <entry>
    <title>Android系统架构</title>
    <link href="http://www.yangxiaozong.com/Android%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.html"/>
    <id>http://www.yangxiaozong.com/Android系统架构.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.230Z</updated>
    
    <content type="html"><![CDATA[<p><img src="images/arch.png" alt=""></p><h2 id="应用程序-Applications"><a href="#应用程序-Applications" class="headerlink" title="应用程序(Applications)"></a>应用程序(Applications)</h2><p>Android会同一系列核心应用程序包一起发布，该应用程序包包括email客户端，SMS短消息程序，日历，地图，浏览器，联系人管理程序等。所有的应用程序都是使用JAVA语言编写的。通常开发人员就处在这一层。</p><h2 id="应用程序框架-Application-Frameworks"><a href="#应用程序框架-Application-Frameworks" class="headerlink" title="应用程序框架(Application Frameworks)"></a>应用程序框架(Application Frameworks)</h2><p>提供应用程序开发的各种API进行快速开发，也即隐藏在每个应用后面的是一系列的服务和系统，大部分使用Java编写，所谓官方源码很多也就是看这里，其中包括：</p><ul><li><strong>丰富而又可扩展的视图（Views）</strong>：可以用来构建应用程序， 它包括列表（lists），网格（grids），文本框（text boxes），按钮（buttons）， 甚至可嵌入的web浏览器。</li><li><strong>内容提供器（Content Providers）</strong>：使得应用程序可以访问另一个应用程序的数据（如联系人数据库）， 或者共享它们自己的数据</li><li><strong>资源管理器（Resource Manager）</strong>：提供 非代码资源的访问，如本地字符串，图形，和布局文件（ layout files ）。</li><li><strong>通知管理器 （Notification Manager）</strong>：使得应用程序可以在状态栏中显示自定义的提示信息。</li><li><strong>活动管理器（ Activity Manager）</strong>：用来管理应用程序生命周期并提供常用的导航回退功能。<a id="more"></a><h2 id="系统运行库与Android运行环境-Libraris-amp-Android-Runtime"><a href="#系统运行库与Android运行环境-Libraris-amp-Android-Runtime" class="headerlink" title="系统运行库与Android运行环境(Libraris &amp; Android Runtime)"></a>系统运行库与Android运行环境(Libraris &amp; Android Runtime)</h2></li></ul><h3 id="系统运行库"><a href="#系统运行库" class="headerlink" title="系统运行库"></a>系统运行库</h3><p>Android 包含一些C/C++库，这些库能被Android系统中不同的组件使用。它们通过 Android 应用程序框架为开发者提供服务。以下是一些核心库：</p><ul><li><strong>Bionic系统 C 库</strong> - 一个从 BSD 继承来的标准 C 系统函数库（ libc ）， 它是专门为基于 embedded linux 的设备定制的。</li><li><strong>媒体库</strong> - 基于 PacketVideo OpenCORE；该库支持多种常用的音频、视频格式回放和录制，同时支持静态图像文件。编码格式包括MPEG4, H.264, MP3, AAC, AMR, JPG, PNG 。</li><li><strong>Surface Manager</strong> - 对显示子系统的管理，并且为多个应用程序提 供了2D和3D图层的无缝融合。这部分代码</li><li><strong>Webkit,LibWebCore</strong> - 一个最新的web浏览器引擎用，支持Android浏览器和一个可嵌入的web视图。鼎鼎大名的 Apple Safari背后的引擎就是Webkit</li><li><strong>SGL</strong> - 底层的2D图形引擎</li><li><strong>3D libraries</strong> - 基于OpenGL ES 1.0 APIs实现；该库可以使用硬件 3D加速（如果可用）或者使用高度优化的3D软加速。</li><li><strong>FreeType</strong> -位图（bitmap）和矢量（vector）字体显示。</li><li><strong>SQLite</strong> - 一个对于所有应用程序可用，功能强劲的轻型关系型数据库引擎。</li></ul><h3 id="Android运行环境"><a href="#Android运行环境" class="headerlink" title="Android运行环境"></a>Android运行环境</h3><p>该核心库提供了JAVA编程语言核心库的大多数功能。<br>每一个Android应用程序都在它自己的进程中运 行，都拥有一个独立的Dalvik虚拟 机实例。Dalvik被设计成一个设备可以同时高效地运行多个虚拟系统。 Dalvik虚拟机执行（.dex）的Dalvik可执行文件，该格式文件针对小内存使用做了 优化。同时虚拟机是基于寄存器的，所有的类都经由JAVA编译器编译，然后通过SDK中 的 “dx” 工具转化成.dex格式由虚拟机执行。</p><h2 id="HAL–硬件抽象层"><a href="#HAL–硬件抽象层" class="headerlink" title="HAL–硬件抽象层"></a>HAL–硬件抽象层</h2><p>其实Android并非讲所有的设备驱动都放在linux内核里面，而是实现在userspace空间，这么做的主要原因是GPL协议，Linux是遵循该协议来发布的，也就意味着对linux内核的任何修改，都必须发布其源代码。而现在这么做就可以避开而无需发布其源代码，毕竟它是用来赚钱的。而在linux内核中为这些userspace驱动代码开一个后门，就可以让本来userspace驱动不可以直接控制的硬件可以被访问。而只需要公布这个后门代码即可。一般情况下如果要将Android移植到其他硬件去运行，只需要实现这部分代码即可。包括：显示器驱动，声音，相机，GPS,GSM等等</p><h2 id="Linux内核-Linux-Kernel"><a href="#Linux内核-Linux-Kernel" class="headerlink" title="Linux内核(Linux Kernel)"></a>Linux内核(Linux Kernel)</h2><p>Android的核心系统服务依赖于Linux 2.6 内核，如安全性，内存管理，进程管理， 网络协议栈和驱动模型。 Linux 内核也同时作为硬件和软件栈之间的抽象层。其外还对其做了部分修改，主要涉及两部分修改：</p><ol><li>Binder (IPC)：提供有效的进程间通信，虽然linux内核本身已经提供了这些功能，但Android系统很多服务都需要用到该功能，为了某种原因其实现了自己的一套。</li><li>电源管理：主要是为了省电，毕竟是手持设备嘛，低耗电才是我们的追求。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;images/arch.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;应用程序-Applications&quot;&gt;&lt;a href=&quot;#应用程序-Applications&quot; class=&quot;headerlink&quot; title=&quot;应用程序(Applications)&quot;&gt;&lt;/a&gt;应用程序(Applications)&lt;/h2&gt;&lt;p&gt;Android会同一系列核心应用程序包一起发布，该应用程序包包括email客户端，SMS短消息程序，日历，地图，浏览器，联系人管理程序等。所有的应用程序都是使用JAVA语言编写的。通常开发人员就处在这一层。&lt;/p&gt;
&lt;h2 id=&quot;应用程序框架-Application-Frameworks&quot;&gt;&lt;a href=&quot;#应用程序框架-Application-Frameworks&quot; class=&quot;headerlink&quot; title=&quot;应用程序框架(Application Frameworks)&quot;&gt;&lt;/a&gt;应用程序框架(Application Frameworks)&lt;/h2&gt;&lt;p&gt;提供应用程序开发的各种API进行快速开发，也即隐藏在每个应用后面的是一系列的服务和系统，大部分使用Java编写，所谓官方源码很多也就是看这里，其中包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;丰富而又可扩展的视图（Views）&lt;/strong&gt;：可以用来构建应用程序， 它包括列表（lists），网格（grids），文本框（text boxes），按钮（buttons）， 甚至可嵌入的web浏览器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内容提供器（Content Providers）&lt;/strong&gt;：使得应用程序可以访问另一个应用程序的数据（如联系人数据库）， 或者共享它们自己的数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源管理器（Resource Manager）&lt;/strong&gt;：提供 非代码资源的访问，如本地字符串，图形，和布局文件（ layout files ）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通知管理器 （Notification Manager）&lt;/strong&gt;：使得应用程序可以在状态栏中显示自定义的提示信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;活动管理器（ Activity Manager）&lt;/strong&gt;：用来管理应用程序生命周期并提供常用的导航回退功能。
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.yangxiaozong.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Binder</title>
    <link href="http://www.yangxiaozong.com/Binder.html"/>
    <id>http://www.yangxiaozong.com/Binder.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.228Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Binder使用<code>Client－Server</code>通信方式。Binder框架定义了四个角色：<code>Server</code>,<code>Client</code>,<code>ServiceManager</code>以及<code>Binder驱动</code>。其中<code>Server</code>,<code>Client</code>,<code>ServiceManager</code>运行于用户空间，驱动运行于内核空间。Binder驱动程序提供设备文件<code>/dev/binder</code>与用户空间交互，<code>Client</code>、<code>Server</code>和<code>Service Manager</code>通过<code>open</code>和<code>ioctl</code>文件操作函数与Binder驱动程序进行通信。</p><p><img src="images/binder.gif" alt=""><br><a id="more"></a></p><h2 id="Binder原理简述"><a href="#Binder原理简述" class="headerlink" title="Binder原理简述"></a>Binder原理简述</h2><ol><li>Server创建了Binder实体，为其取一个字符形式，可读易记的名字。</li><li>将这个Binder连同名字以数据包的形式通过Binder驱动发送给<code>ServiceManager</code>，通知<code>ServiceManager</code>注册一个名字为XX的Binder，它位于Server中。</li><li>驱动为这个穿过进程边界的Binder创建位于内核中的实体结点以及ServiceManager对实体的引用，将名字以及新建的引用打包给ServiceManager。</li><li><code>ServiceManager</code>收数据包后，从中取出名字和引用填入一张查找表中。但是一个Server若向ServiceManager注册自己Binder就必须通过这个引用和<code>ServiceManager</code>的Binder通信。</li><li>Server向<code>ServiceManager</code>注册了Binder实体及其名字后，Client就可以通过名字获得该Binder的引用了。Clent也利用保留的引用向<code>ServiceManager</code>请求访问某个Binder：我申请名字叫XX的Binder的引用。</li><li><code>ServiceManager</code>收到这个连接请求，从请求数据包里获得Binder的名字，在查找表里找到该名字对应的条目，从条目中取出Binder引用，将该引用作为回复发送给发起请求的Client。</li></ol><p>当然，不是所有的Binder都需要注册给<code>ServiceManager</code>广而告之的。Server端可以通过已经建立的Binder连接将创建的Binder实体传给Client，当然这条已经建立的Binder连接必须是通过实名Binder实现。由于这个Binder没有向ServiceManager注册名字，所以是 <strong>匿名Binder</strong>。Client将会收到这个匿名Binder的引用，通过这个引用向位于Server中的实体发送请求。匿名Binder为通信双方建立一条私密通道，只要Server没有把匿名Binder发给别的进程，别的进程就无法通过穷举或猜测等任何方式获得该Binder的引用，向该Binder发送请求。</p><h2 id="Binder的数据拷贝"><a href="#Binder的数据拷贝" class="headerlink" title="Binder的数据拷贝"></a>Binder的数据拷贝</h2><p>Linux内核实际上没有从一个用户空间到另一个用户空间直接拷贝的函数，需要先用<code>copy_from_user()</code>拷贝到内核空间，再用<code>copy_to_user()</code>拷贝到另一个用户空间。<strong>为了实现用户空间到用户空间的拷贝，<code>mmap()</code>分配的内存除了映射进了接收方进程里，还映射进了内核空间</strong>。所以调用<code>copy_from_user()</code>将数据拷贝进内核空间也相当于拷贝进了接收方的用户空间，这就是Binder只需一次拷贝的”秘密”。</p><p>最底层的是Android的<code>ashmen(Anonymous shared memory)</code>机制，它负责辅助实现内存的分配，以及跨进程所需要的内存共享。AIDL(android interface definition language)对Binder的使用进行了封装，可以让开发者方便的进行方法的远程调用，后面会详细介绍。Intent是最高一层的抽象，方便开发者进行常用的跨进程调用。</p><p>使用共享内存通信的一个显而易见的好处是效率高，因为 <strong>进程可以直接读写内存，而不需要任何数据的拷贝</strong>。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次内存数据：一次从输入文件到共享内存区，另一次从共享内存到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域，而是保持共享区域，直到通信完成为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除内存映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。</p><h3 id="Window绘制过程"><a href="#Window绘制过程" class="headerlink" title="Window绘制过程"></a>Window绘制过程</h3><p>在理解<code>Window</code>绘制过程之前，首先，我们需要知道<code>Surface</code>，在<code>Window</code>中持有一个<code>Surface</code>，那么什么是<code>Surface</code>呢？</p><p><code>Surface</code>其实就是一个持有像素点矩阵的对象，这个像素点矩阵是组成显示在屏幕的图像的一部分。<strong>我们看到显示的每个Window（包括对话框、全屏的Activity、状态栏等）都有他自己绘制的<code>Surface</code></strong>。而最终的显示可能存在<code>Window</code>之间遮挡的问题，此时就是通过<code>Surface Flinger对</code>象渲染最终的显示，使他们以正确的<code>Z-order</code>显示出来。一般<code>Surface</code>拥有一个或多个缓存（一般2个），通过双缓存来刷新，这样就可以一边绘制一边加新缓存。</p><p><code>WindowManager</code>为每个<code>Window</code>创建<code>Surface</code>对象，然后应用就可以通过这个<code>Surface</code>来绘制任何它想要绘制的东西。而对于<code>WindowManager</code>来说，这只不过是一块矩形区域而已。</p><p>前面我们说过，<code>View</code>是<code>Window</code>里面用于交互的UI元素。<code>Window</code>只attach一个<code>View Tree</code>，当<code>Window</code>需要重绘（如，当View调用<code>invalidate</code>）时，最终转为<code>Window</code>的<code>Surface</code>，<code>Surface</code>被锁住（locked）并返回Canvas对象，此时View拿到Canvas对象来绘制自己。当所有View绘制完成后，<code>Surface</code>解锁（unlock），并且post到绘制缓存用于绘制，通过<code>Surface Flinger</code>来组织各个Window，显示最终的整个屏幕。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们知道了<code>Window</code>绘制过程，其实，站在系统的角度来考虑，一个Window对象代表一块显示区域，系统不关心Window里面具体的绘制内容，也不管你<code>Window</code>怎么去绘制，反正只给你提供可以在这块区域上绘制图形的<code>Surface</code>对象，你<code>Window</code>对象怎么画是你的事情！</p><p>换句话说，站在系统的角度上看，系统是“不知道”有View对象这个说法的！作为系统，我有自己的骄傲，不去管你Window如何搬砖、如何砌墙，只给你地皮。而这时，Window为了绘制出用户想要的组件（按钮、文字、输入框等等），系统又不给我！没事，那我自己定义，于是就定义了View机制，给每个View提供Canvas，让不同的View自己绘制具有自己特色的组件。同时，为了更好的管理View，通过定义ViewGroup，等等。</p><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><p>对于开发人员来说，一个<code>Activity</code>就“相当于”一个界面（通过<code>setContentView</code>指定具体的View）。我们可以直接在Activity里处理事件，如<code>onKeyEvent</code>,<code>onTouchEvent</code>等。 并可以通过Activity维护应用程序的生命周期。</p><h3 id="Activity和Window"><a href="#Activity和Window" class="headerlink" title="Activity和Window"></a>Activity和Window</h3><p>前面我们知道，<code>Window</code>已经是系统管理的窗口界面。那么为什么还需要<code>Activity</code>呢？我们把<code>Activity</code>所做的事情，全部封装到<code>Window</code>不就好了？</p><p>其实，本质上讲，我们要显示一个窗口出来，的确可以不需要Activity。悬浮窗口中不就是没有使用Activity来显示一个悬浮窗吗？既然如此，Window（以及View）能处理点击事件以及封装各种逻辑，那为啥还需要Activity呢？</p><p><code>Android</code>中的应用中，里面对各个窗口的管理相当复杂（任务栈、状态等等），Android系统当然可以不用Activity，让用户自己直接操作Window来开发自己的应用。但是如果让用户自己去管理这些Window，先不说工作量，光让用户自己去实现任务栈这点，有几个人能写的出来。<strong>为了让大家能简单、快速的开发应用，Android通过定义Activity，让Activity帮我们管理好，我们只需简单的去重写几个回调函数，无需直接与Window对象接触</strong>。各种事件也只需重写Activity里面的回调即可。无需关注其他细节，默认都帮我们写好了，针对需要定制的部分我们重写（设计模式为：模板方法模式）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Binder使用&lt;code&gt;Client－Server&lt;/code&gt;通信方式。Binder框架定义了四个角色：&lt;code&gt;Server&lt;/code&gt;,&lt;code&gt;Client&lt;/code&gt;,&lt;code&gt;ServiceManager&lt;/code&gt;以及&lt;code&gt;Binder驱动&lt;/code&gt;。其中&lt;code&gt;Server&lt;/code&gt;,&lt;code&gt;Client&lt;/code&gt;,&lt;code&gt;ServiceManager&lt;/code&gt;运行于用户空间，驱动运行于内核空间。Binder驱动程序提供设备文件&lt;code&gt;/dev/binder&lt;/code&gt;与用户空间交互，&lt;code&gt;Client&lt;/code&gt;、&lt;code&gt;Server&lt;/code&gt;和&lt;code&gt;Service Manager&lt;/code&gt;通过&lt;code&gt;open&lt;/code&gt;和&lt;code&gt;ioctl&lt;/code&gt;文件操作函数与Binder驱动程序进行通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/binder.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="Binder" scheme="http://www.yangxiaozong.com/tags/Binder/"/>
    
  </entry>
  
  <entry>
    <title>Canvas</title>
    <link href="http://www.yangxiaozong.com/Canvas.html"/>
    <id>http://www.yangxiaozong.com/Canvas.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.227Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><strong>save</strong>：用来保存 Canvas 的状态。save 之后，可以调用 Canvas 的平移、放缩、旋转、错切、裁剪等操作。</p></li><li><p><strong>restore</strong>：用来恢复Canvas之前保存的状态。防止 save 后对 Canvas 执行的操作对后续的绘制有影响。</p></li></ul><p>save 和 restore 要配对使用( restore 可以比 save 少，但不能多)，如果 restore 调用次数比 save 多，会引发 Error 。save 和 restore 之间，往往夹杂的是对 Canvas 的特殊操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;save&lt;/strong&gt;：用来保存 Canvas 的状态。save 之后，可以调用 Canvas 的平移、放缩、旋转、错切、裁剪等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;restore&lt;/strong&gt;：用来恢复Canv
      
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="Canvas" scheme="http://www.yangxiaozong.com/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>Event</title>
    <link href="http://www.yangxiaozong.com/Event.html"/>
    <id>http://www.yangxiaozong.com/Event.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.227Z</updated>
    
    <content type="html"><![CDATA[<p>事件的分发机制由三个重要方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent</p><ul><li><p>事件分发：public boolean dispatchTouchEvent(MotionEvent ev)：用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的DispatchTouchEvent方法的影响，表示是否消耗当前事件。</p></li><li><p>事件拦截：public boolean onInterceptTouchEvent(MotionEvent event)：在上述方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。</p></li><li><p>事件响应：public boolean onTouchEvent(MotionEvent event)：在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。</p></li></ul><p>三者的关系可以总结为如下伪代码：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">        consume = onTouchEvent(ev);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>同一个事件序列是从手指触摸屏幕的那一刻起，到手指离开屏幕那一刻结束，这个过程中所产生的一系列事件。这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。</p></li><li><p>一个事件序列只能被一个View拦截且消耗，不过通过事件代理<code>TouchDelegate</code>，可以将<code>onTouchEvent</code>强行传递给其他View处理。</p></li><li><p><strong>某个View一旦决定拦截，那么这一事件序列就都只能由它来处理</strong>。</p></li><li><p><strong>某个View一旦开始处理事件，如果不消耗ACTION_DOWN事件（onTouchEvent返回了false），那么事件会重新交给它的父元素处理，即父元素的onTouchEvent会被调用</strong>。</p></li><li><p>如果View不消耗除<code>ACTION_DOWN</code>以外的事件，那么这个点击事件会消失，此时父元素的<code>onTouchEvent</code>并不会调用，并且当前View可以持续收到后续的事件（Android系统通过一个标记来解决），最终这些消失的事件会传递到Activity。</p></li><li><p><code>ViewGroup</code>默认不拦截任何事件。Android源码中<code>ViewGroup</code>的<code>onInterceptTouchEvent</code>方法默认返回false。</p></li><li><p><strong>View没有<code>onIntercepteTouchEvent</code>方法，一旦有点击事件传递给它，那么它的<code>onTouchEvent</code>方法就会被调用</strong>。</p></li><li><p>View的<code>onTouchEvent</code>默认都不会消耗事件（返回false），除非它是可点击的（<code>clickable</code>和<code>longClickable</code>有一个为true）。View的<code>longClickable</code>默认都为false，clickable要分情况看，比如Button默认为true，TextView默认为false。</p></li><li><p>View的<code>enable</code>属性不影响<code>onTouchEvent</code>的默认返回值。哪怕一个View是<code>disable</code>状态，只要它的<code>clickable</code>或者<code>longClickable</code>有一个为true，那么它的<code>onTouchEvent</code>就返回true。</p></li><li><p><code>onClick</code>会发生的前提是当前View是可点击的，并且它受到down和up的事件。</p></li><li><p>事件传递是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子View，<strong>通过<code>requestDisallowInterceptTouchEvent</code>方法就可以在子元素中干扰父元素的事件分发过程</strong>，但ACTION_DOWN事件除外。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;事件的分发机制由三个重要方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;事件分发：public boolean dispatchTouchEvent(MotionEvent ev)：用来进行事件的分发。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级View的DispatchTouchEvent方法的影响，表示是否消耗当前事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事件拦截：public boolean onInterceptTouchEvent(MotionEvent event)：在上述方法内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;事件响应：public boolean onTouchEvent(MotionEvent event)：在dispatchTouchEvent方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前View无法再次接收到事件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三者的关系可以总结为如下伪代码：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="Event" scheme="http://www.yangxiaozong.com/tags/Event/"/>
    
  </entry>
  
  <entry>
    <title>EventBus</title>
    <link href="http://www.yangxiaozong.com/EventBus.html"/>
    <id>http://www.yangxiaozong.com/EventBus.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="EventBus消息接收者注册流程"><a href="#EventBus消息接收者注册流程" class="headerlink" title="EventBus消息接收者注册流程"></a>EventBus消息接收者注册流程</h3><p><img src="images/EventBus.register.png" alt=""></p><h3 id="EventBus-Post流程"><a href="#EventBus-Post流程" class="headerlink" title="EventBus Post流程"></a>EventBus Post流程</h3><p><img src="images/EventBus.Post.png" alt=""></p><p><code>postToSubscription()</code>在这个方法中，实现了从发布者到调用者的调用过程。在这里有很重要的几个分支：<br><a id="more"></a></p><ul><li><p><strong>Main</strong>：在主线程中执行。</p><ul><li>如果当前线程(post线程)是主线程，则直接invoke；</li><li>如果当前线程(post线程)不是主线程，则将消息放入一个<code>HandlerPosterPendingPostQueue</code>的消息队列中，然后通过主线程的Handler发送消息，最好在<code>Handler.HandleMessage</code>中调用<code>EventBus.invokeSubscriber</code>，来让订阅方法在主线程中执行。</li></ul></li><li><p><strong>BackGround</strong>：在后台线程执行。</p><ul><li>如果当前线程(post线程)不是主线程，则直接invoke；</li><li>如果当前线程(post线程)是主线程，则将消息放入<code>BackgroundPoster.PendingPostQueue</code>的消息队列中，由于该Poster实现了接口<code>Runable</code>，于是将该Poster放入线程池中执行，在线程中调用<code>EventBus.invokeSubscriber</code>。</li></ul></li><li><p><strong>Async</strong>：异步执行。将消息放入<code>AsyncPoster</code>中，然后将该Poster放入线程池并调用<code>EventBus.invokeSubscriber</code>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;EventBus消息接收者注册流程&quot;&gt;&lt;a href=&quot;#EventBus消息接收者注册流程&quot; class=&quot;headerlink&quot; title=&quot;EventBus消息接收者注册流程&quot;&gt;&lt;/a&gt;EventBus消息接收者注册流程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;images/EventBus.register.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;EventBus-Post流程&quot;&gt;&lt;a href=&quot;#EventBus-Post流程&quot; class=&quot;headerlink&quot; title=&quot;EventBus Post流程&quot;&gt;&lt;/a&gt;EventBus Post流程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;images/EventBus.Post.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;postToSubscription()&lt;/code&gt;在这个方法中，实现了从发布者到调用者的调用过程。在这里有很重要的几个分支：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="EventBus" scheme="http://www.yangxiaozong.com/tags/EventBus/"/>
    
  </entry>
  
  <entry>
    <title>Handler</title>
    <link href="http://www.yangxiaozong.com/Handler.html"/>
    <id>http://www.yangxiaozong.com/Handler.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Looper-prepare"><a href="#1-Looper-prepare" class="headerlink" title="1.Looper.prepare"></a>1.Looper.prepare</h2><p>首先从<code>ThreadLocal</code>中获取一个<code>Looper</code>，如果没有则向<code>ThreadLocal</code>中添加一个<code>new Looper</code>，同时新建一个<code>MessageQueue</code>。</p><blockquote><p>主线程的Looper在ActivityThread创建。</p></blockquote><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><code>ThreadLocal</code>是Java提供的用于保存同一进程中不同线程数据的一种机制。每个线程中都保有一个<code>ThreadLocalMap</code>的成员变量，<code>ThreadLocalMap</code>内部采用<code>WeakReference</code>数组保存，数组的key即为<code>ThreadLocal</code>内部的Hash值。<br><a id="more"></a></p><h2 id="2-Looper-loop"><a href="#2-Looper-loop" class="headerlink" title="2.Looper.loop"></a>2.Looper.loop</h2><p>循环调用<code>MessageQueue.next</code>获取消息，该函数在<code>MessageQueue</code>中没有消息的时候会阻塞，这里采用了<code>epoll</code>的I/O多路复用机制。当获取到一个消息的时候会返回。</p><h2 id="3-Mseeage-target-dispatchMessage"><a href="#3-Mseeage-target-dispatchMessage" class="headerlink" title="3.Mseeage.target.dispatchMessage"></a>3.Mseeage.target.dispatchMessage</h2><p>在loop中获取到消息后，会调用Message内部的Handler引用并分派事件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Looper-prepare&quot;&gt;&lt;a href=&quot;#1-Looper-prepare&quot; class=&quot;headerlink&quot; title=&quot;1.Looper.prepare&quot;&gt;&lt;/a&gt;1.Looper.prepare&lt;/h2&gt;&lt;p&gt;首先从&lt;code&gt;ThreadLocal&lt;/code&gt;中获取一个&lt;code&gt;Looper&lt;/code&gt;，如果没有则向&lt;code&gt;ThreadLocal&lt;/code&gt;中添加一个&lt;code&gt;new Looper&lt;/code&gt;，同时新建一个&lt;code&gt;MessageQueue&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主线程的Looper在ActivityThread创建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ThreadLocal&quot;&gt;&lt;a href=&quot;#ThreadLocal&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal&quot;&gt;&lt;/a&gt;ThreadLocal&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;是Java提供的用于保存同一进程中不同线程数据的一种机制。每个线程中都保有一个&lt;code&gt;ThreadLocalMap&lt;/code&gt;的成员变量，&lt;code&gt;ThreadLocalMap&lt;/code&gt;内部采用&lt;code&gt;WeakReference&lt;/code&gt;数组保存，数组的key即为&lt;code&gt;ThreadLocal&lt;/code&gt;内部的Hash值。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="Handler" scheme="http://www.yangxiaozong.com/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>Android面试题</title>
    <link href="http://www.yangxiaozong.com/Android%E9%9D%A2%E8%AF%95%E9%A2%98.html"/>
    <id>http://www.yangxiaozong.com/Android面试题.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.229Z</updated>
    
    <content type="html"><![CDATA[<h3 id="APK安装过程"><a href="#APK安装过程" class="headerlink" title="APK安装过程"></a>APK安装过程</h3><p>应用安装涉及到如下几个目录：</p><ul><li><strong>system/app</strong>：系统自带的应用程序，无法删除</li><li><strong>data/app</strong>：用户程序安装的目录，有删除权限。安装时把apk文件复制到此目录</li><li><strong>data/data</strong>：存放应用程序的数据</li><li><strong>data/dalvik-cache</strong>：将apk中的dex文件安装到dalvik-cache目录下</li></ul><p>复制APK安装包到data/app目录下，解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录，并在data/data目录下创建对应的应用数据目录。</p><hr><h3 id="invalidate-和postInvalidate-的区别"><a href="#invalidate-和postInvalidate-的区别" class="headerlink" title="invalidate()和postInvalidate() 的区别"></a>invalidate()和postInvalidate() 的区别</h3><ul><li><code>invalidate()</code>是用来刷新View的，必须是在UI线程中进行工作。比如在修改某个view的显示时，调用invalidate()才能看到重新绘制的界面。</li><li><code>postInvalidate()</code>在工作者线程中被调用。</li></ul><hr><h3 id="导入外部数据库"><a href="#导入外部数据库" class="headerlink" title="导入外部数据库"></a>导入外部数据库</h3><p>Android系统下数据库应该存放在 <code>/data/data/com.*.*(package name)/</code> 目录下，所以我们需要做的是把已有的数据库传入那个目录下。操作方法是用<code>FileInputStream</code>读取原数据库，再用<code>FileOutputStream</code>把读取到的东西写入到那个目录。<br><a id="more"></a></p><hr><h3 id="Parcelable和Serializable区别"><a href="#Parcelable和Serializable区别" class="headerlink" title="Parcelable和Serializable区别"></a>Parcelable和Serializable区别</h3><p><code>Parcelable</code>的性能比<code>Serializable</code>好，在内存开销方面较小，所以在内存间数据传输时推荐使用<code>Parcelable</code>，如activity间传输数据，而<code>Serializable</code>可将数据持久化方便保存，所以在需要保存或网络传输数据时选择<code>Serializable</code>，因为android不同版本<code>Parcelable</code>可能不同，所以不推荐使用<code>Parcelable</code>进行数据持久化。</p><p><code>Serializable</code>序列化不保存静态变量，可以使用<code>Transient</code>关键字对部分字段不进行序列化，也可以覆盖<code>writeObject</code>、<code>readObject</code>方法以实现序列化过程自定义。</p><hr><h3 id="Android里跨进程传递数据的几种方案"><a href="#Android里跨进程传递数据的几种方案" class="headerlink" title="Android里跨进程传递数据的几种方案"></a>Android里跨进程传递数据的几种方案</h3><ul><li>Binder</li><li>Socket/LocalSocket</li><li>共享内存</li></ul><hr><h3 id="匿名共享内存，使用场景"><a href="#匿名共享内存，使用场景" class="headerlink" title="匿名共享内存，使用场景"></a>匿名共享内存，使用场景</h3><p>在Android系统中，提供了独特的匿名共享内存子系统<code>Ashmem(Anonymous Shared Memory)</code>，它以驱动程序的形式实现在内核空间中。它有两个特点，一是能够辅助内存管理系统来有效地管理不再使用的内存块，二是它通过Binder进程间通信机制来实现进程间的内存共享。</p><p><code>ashmem</code>并像<code>Binder</code>是Android重新自己搞的一套东西，而是利用了Linux的 <strong>tmpfs文件系统</strong>。tmpfs是一种可以基于RAM或是SWAP的高速文件系统，然后可以拿它来实现不同进程间的内存共享。</p><p>大致思路和流程是：</p><ul><li>Proc A 通过 tmpfs 创建一块共享区域，得到这块区域的 fd（文件描述符）</li><li>Proc A 在 fd 上 mmap 一片内存区域到本进程用于共享数据</li><li>Proc A 通过某种方法把 fd 倒腾给 Proc B</li><li>Proc B 在接到的 fd 上同样 mmap 相同的区域到本进程</li><li>然后 A、B 在 mmap 到本进程中的内存中读、写，对方都能看到了</li></ul><p>其实核心点就是 <strong>创建一块共享区域，然后2个进程同时把这片区域 mmap 到本进程，然后读写就像本进程的内存一样</strong>。这里要解释下第3步，为什么要倒腾 fd，因为在 linux 中 fd 只是对本进程是唯一的，在 Proc A 中打开一个文件得到一个 fd，但是把这个打开的 fd 直接放到 Proc B 中，Proc B 是无法直接使用的。但是文件是唯一的，就是说一个文件（file）可以被打开多次，每打开一次就有一个 fd（文件描述符），所以对于同一个文件来说，需要某种转化，把 Proc A 中的 fd 转化成 Proc B 中的 fd。这样 Proc B 才能通过 fd mmap 同样的共享内存文件。</p><p>使用场景：进程间大量数据传输。</p><hr><h3 id="ContentProvider实现原理"><a href="#ContentProvider实现原理" class="headerlink" title="ContentProvider实现原理"></a>ContentProvider实现原理</h3><p>ContentProvider 有以下两个特点：</p><ul><li><strong>封装</strong>：对数据进行封装，提供统一的接口，使用者完全不必关心这些数据是在DB，XML、Preferences或者网络请求来的。当项目需求要改变数据来源时，使用我们的地方完全不需要修改。</li><li><strong>提供一种跨进程数据共享的方式</strong>。</li></ul><p><code>Content Provider</code>组件在不同应用程序之间传输数据是基于匿名共享内存机制来实现的。其主要的调用过程：</p><ol><li><p>通过ContentResolver先查找对应给定Uri的ContentProvider，返回对应的<code>BinderProxy</code></p><ul><li><p>如果该Provider尚未被调用进程使用过:</p><ul><li>通过<code>ServiceManager</code>查找activity service得到<code>ActivityManagerService</code>对应<code>BinderProxy</code></li><li>调用<code>BinderProxy</code>的transcat方法发送<code>GET_CONTENT_PROVIDER_TRANSACTION</code>命令，得到对应<code>ContentProvider</code>的<code>BinderProxy</code>。</li></ul></li><li><p>如果该Provider已被调用进程使用过，则调用进程会保留使用过provider的HashMap。此时直接从此表查询即得。</p></li></ul></li><li><p>调用<code>BinderProxy</code>的<code>query()</code></p></li></ol><hr><h3 id="如何使用ContentProvider进行批量操作？"><a href="#如何使用ContentProvider进行批量操作？" class="headerlink" title="如何使用ContentProvider进行批量操作？"></a>如何使用ContentProvider进行批量操作？</h3><p>通常进行数据的批量操作我们都会使用“事务”，但是<code>ContentProvider</code>如何进行批量操作呢？创建 <code>ContentProviderOperation</code> 对象数组，然后使用 <code>ContentResolver.applyBatch()</code> 将其分派给内容提供程序。您需将内容提供程序的授权传递给此方法，而不是特定内容 <code>URI</code>。这样可使数组中的每个 <code>ContentProviderOperation</code> 对象都能适用于其他表。调用 <code>ContentResolver.applyBatch()</code> 会返回结果数组。</p><p>同时我们还可以通过<code>ContentObserver</code>对数据进行观察：</p><ol><li>创建我们特定的<code>ContentObserver</code>派生类，必须重载<code>onChange()</code>方法去处理回调后的功能实现</li><li>利用<code>context.getContentResolover()</code>获得<code>ContentResolove</code>对象，接着调用<code>registerContentObserver()</code>方法去注册内容观察者，为指定的Uri注册一个<code>ContentObserver</code>派生类实例，当给定的Uri发生改变时，回调该实例对象去处理。</li><li>由于<code>ContentObserver</code>的生命周期不同步于Activity和Service等，因此，在不需要时，需要手动的调用<code>unregisterContentObserver()</code>去取消注册。</li></ol><hr><h3 id="Application类的作用"><a href="#Application类的作用" class="headerlink" title="Application类的作用"></a>Application类的作用</h3><p> Android系统会为每个程序运行时创建一个<code>Application</code>类的对象且仅创建一个，所以Application可以说是单例 (singleton)模式的一个类。<code>Application</code>对象的生命周期是整个程序中最长的，它的生命周期就等于这个程序的生命周期。因为它是全局的单例的，所以在不同的<code>Activity</code>,<code>Service</code>中获得的对象都是同一个对象。所以通过<code>Application</code>来进行一些，数据传递，数据共享，数据缓存等操作。</p><hr><h3 id="广播注册后不解除注册会有什么问题？-内存泄露"><a href="#广播注册后不解除注册会有什么问题？-内存泄露" class="headerlink" title="广播注册后不解除注册会有什么问题？(内存泄露)"></a>广播注册后不解除注册会有什么问题？(内存泄露)</h3><p>我们可以通过两种方式注册<code>BroadcastReceiver</code>，一是在Activity启动过程中通过代码动态注册，二是在AndroidManifest.xml文件中利用<code>&lt;receiver&gt;</code>标签进行静态注册。</p><ul><li>对于第一种方法，我们需要养成一个良好的习惯：在Activity进入停止或者销毁状态的时候使用<code>unregisterReceiver</code>方法将注册的<code>BroadcastReceiver</code>注销掉。</li><li>对于<code>&lt;receiver&gt;</code>标签进行注册的，那么该对象的实例在<code>onReceive</code>被调用之后就会在任意时间内被销毁。</li></ul><hr><h3 id="属性动画-Property-Animation-和补间动画-Tween-Animation-的区别"><a href="#属性动画-Property-Animation-和补间动画-Tween-Animation-的区别" class="headerlink" title="属性动画(Property Animation)和补间动画(Tween Animation)的区别"></a>属性动画(Property Animation)和补间动画(Tween Animation)的区别</h3><ul><li>补间动画只是针对于View，超脱了View就无法操作了。</li><li>补间动画有四种动画操作（移动，缩放，旋转，淡入淡出）。</li><li>补间动画只是改变View的显示效果而已，但是不会真正的去改变View的属性。</li><li>属性动画改变View的实际属性值，当然它也可以不作用于View。</li></ul><hr><h3 id="BrocastReceive里面可不可以执行耗时操作"><a href="#BrocastReceive里面可不可以执行耗时操作" class="headerlink" title="BrocastReceive里面可不可以执行耗时操作?"></a>BrocastReceive里面可不可以执行耗时操作?</h3><p>不能，当 <code>onReceive()</code> 方法在 10 秒内没有执行完毕，Android 会认为该程序无响应，所以在<code>BroadcastReceiver</code>里不能做一些比较耗时的操作，否侧会弹出 ANR 的对话框。</p><hr><h3 id="Android优化工具"><a href="#Android优化工具" class="headerlink" title="Android优化工具"></a>Android优化工具</h3><h4 id="TraceView"><a href="#TraceView" class="headerlink" title="TraceView"></a>TraceView</h4><p>traceview 是Android SDK中自带的一个工具，可以 <strong>对应用中方法调用耗时进行统计分析，是Android性能优化和分析时一个很重要的工具</strong>。使用方法：第一种是在相应进行traceview分析的开始位置和结束位置分别调用<code>startMethodTracing</code>和<code>stopMethodTracing</code>方法。第二种是在ddms中直接使用，即在ddms中在选中某个要进行监控的进程后，点击如图所示的小图标开始监控，在监控结束时再次点击小图标，ddms会自动打开traceview视图。</p><h4 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h4><p>Systrace是Android4.1中新增的性能数据采样和分析工具。它可帮助开发者收集Android关键子系统（如<code>surfaceflinger</code>、<code>WindowManagerService</code>等Framework部分关键模块、服务）的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p><p>Systrace的功能包括跟踪系统的I/O操作、内核工作队列、CPU负载以及Android各个子系统的运行状况等。</p><hr><h3 id="Dalvik与ART的区别？"><a href="#Dalvik与ART的区别？" class="headerlink" title="Dalvik与ART的区别？"></a>Dalvik与ART的区别？</h3><p>Dalvik是Google公司自己设计用于Android平台的Java虚拟机。Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一，它可以支持已转换为.dex(即Dalvik Executable)格式的Java应用程序的运行，.dex格式是专为Dalvik应用设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为独立的Linux进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。</p><p>ART代表<code>Android Runtime</code>,其处理应用程序执行的方式完全不同于Dalvik，<strong>Dalvik是依靠一个Just-In-Time(JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，在应用安装的时候就预编译字节码到机器语言，这一机制叫 Ahead-Of-Time(AOT) 编译</strong> 。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。</p><p>ART优点：</p><ol><li>系统性能的显著提升</li><li>应用启动更快、运行更快、体验更流畅、触感反馈更及时</li><li>更长的电池续航能力</li><li>支持更低的硬件</li></ol><p>ART缺点：</p><ol><li>更大的存储空间占用，可能会增加10%-20%</li><li>更长的应用安装时间</li></ol><hr><h3 id="Android动态权限？"><a href="#Android动态权限？" class="headerlink" title="Android动态权限？"></a>Android动态权限？</h3><p>Android 6.0 动态权限，这里以拨打电话的权限为例，首先需要在Manifest里添加<code>android.permission.CALL_PHONE</code>权限。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int checkCallPhonePermission = ContextCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE);</span><br><span class="line">    if (checkCallPhonePermission != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        ActivityCompat.requestPermissions(</span><br><span class="line">                this, new String[]&#123;Manifest.permission.CALL_PHONE&#125;, REQUEST_CODE_ASK_CALL_PHONE);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在获取权限后，可以重写Activity.onRequestPermissionsResult方法来进行回调。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions,</span><br><span class="line">                                       @NonNull int[] grantResults) &#123;</span><br><span class="line">    switch (requestCode) &#123;</span><br><span class="line">        case REQUEST_CODE_ASK_CALL_PHONE:</span><br><span class="line">            if (grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                // Permission Granted</span><br><span class="line">                Toast.makeText(MainActivity.this, &quot;CALL_PHONE Granted&quot;, Toast.LENGTH_SHORT)</span><br><span class="line">                        .show();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Permission Denied</span><br><span class="line">                Toast.makeText(MainActivity.this, &quot;CALL_PHONE Denied&quot;, Toast.LENGTH_SHORT)</span><br><span class="line">                        .show();</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            super.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ViewPager如何判断左右滑动？"><a href="#ViewPager如何判断左右滑动？" class="headerlink" title="ViewPager如何判断左右滑动？"></a>ViewPager如何判断左右滑动？</h3><p>实现<code>OnPageChangeListener</code>并重写<code>onPageScrolled</code>方法，通过参数进行判断。</p><hr><h3 id="ListView与RecyclerView"><a href="#ListView与RecyclerView" class="headerlink" title="ListView与RecyclerView"></a>ListView与RecyclerView</h3><ol><li><p><strong>ViewHolder</strong>：在ListView中，ViewHolder需要自己来定义，且这只是一种推荐的使用方式，不使用当然也可以，这不是必须的。而在RecyclerView中使用 <code>RecyclerView.ViewHolder</code> 则变成了必须，尽管实现起来稍显复杂，但它却解决了ListView面临的上述不使用自定义ViewHolder时所面临的问题。</p></li><li><p><strong>LayoutManager</strong>：RecyclerView提供了更加丰富的布局管理。<code>LinearLayoutManager</code>，可以支持水平和竖直方向上滚动的列表。<code>StaggeredGridLayoutManager</code>，可以支持交叉网格风格的列表，类似于瀑布流或者Pinterest。<code>GridLayoutManager</code>，支持网格展示，可以水平或者竖直滚动，如展示图片的画廊。</p></li><li><p><strong>ItemAnimator</strong>：相比较于ListView，<code>RecyclerView.ItemAnimator</code> 则被提供用于在<code>RecyclerView</code>添加、删除或移动item时处理动画效果。</p></li><li><p><strong>ItemDecoration</strong>：RecyclerView在默认情况下并不在item之间展示间隔符。如果你想要添加间隔符，你必须使用<code>RecyclerView.ItemDecoration</code>类来实现。</p></li></ol><p>ListView可以设置选择模式，并添加<code>MultiChoiceModeListener</code>，<code>RecyclerView</code>中并没有提供这样功能。</p><hr><h3 id="SpannableString"><a href="#SpannableString" class="headerlink" title="SpannableString"></a>SpannableString</h3><p>TextView通常用来显示普通文本，但是有时候需要对其中某些文本进行样式、事件方面的设置。Android系统通过<code>SpannableString</code>类来对指定文本进行相关处理。可以通过<code>SpannableString</code>来对TextView进行富文本设置，包括但不限于文本颜色，删除线，图片，超链接，字体样式。</p><hr><h3 id="描述一下Android手机启动过程和App启动过程？"><a href="#描述一下Android手机启动过程和App启动过程？" class="headerlink" title="描述一下Android手机启动过程和App启动过程？"></a>描述一下Android手机启动过程和App启动过程？</h3><h4 id="Android手机启动过程"><a href="#Android手机启动过程" class="headerlink" title="Android手机启动过程"></a>Android手机启动过程</h4><p>当我们开机时，首先是启动Linux内核，在Linux内核中首先启动的是init进程，这个进程会去读取配置文件<code>system\core\rootdir\init.rc</code>配置文件，这个文件中配置了Android系统中第一个进程Zygote进程。</p><p>启动Zygote进程 –&gt; 创建AppRuntime（Android运行环境） –&gt; 启动虚拟机 –&gt; 在虚拟机中注册JNI方法 –&gt; 初始化进程通信使用的Socket（用于接收AMS的请求） –&gt; 启动系统服务进程 –&gt; 初始化时区、键盘布局等通用信息 –&gt; 启动Binder线程池 –&gt; 初始化系统服务（包括PMS，AMS等等） –&gt; 启动Launcher</p><h4 id="App启动过程"><a href="#App启动过程" class="headerlink" title="App启动过程"></a>App启动过程</h4><p><img src="images/app_launch.jpg" alt=""></p><ol><li><p>应用的启动是从其他应用调用<code>startActivity</code>开始的。通过代理请求AMS启动Activity。</p></li><li><p>AMS创建进程，并进入<code>ActivityThread</code>的main入口。在main入口，主线程初始化，并loop起来。主线程初始化，主要是实例化<code>ActivityThread</code>和<code>ApplicationThread</code>，以及<code>MainLooper</code>的创建。<code>ActivityThread</code>和<code>ApplicationThread</code>实例用于与AMS进程通信。</p></li><li><p>应用进程将实例化的<code>ApplicationThread</code>，<code>Binder</code>传递给AMS，这样AMS就可以通过代理对应用进程进行访问。</p></li><li><p>AMS通过代理，请求启动Activity。<code>ApplicationThread</code>通知主线程执行该请求。然后，<code>ActivityThread</code>执行Activity的启动。</p></li><li><p>Activity的启动包括，Activity的实例化，Application的实例化，以及Activity的启动流程：create、start、resume。</p></li></ol><p>可以看到 <strong>入口Activity其实是先于Application实例化，只是onCreate之类的流程，先于Activity的流程</strong>。另外需要<code>scheduleLaunchActivity</code>，在<code>ApplicationThreaad</code>中，对应AMS管理Activity生命周期的方法都以<code>scheduleXXXActivity</code>，ApplicationThread在Binder线程中，它会向主线程发送消息，ActivityThread的Handler会调用相应的handleXXXActivity方法，然后会执行performXXXActivity方法，最终调用Activity的onXXX方法</p><hr><h3 id="Include、Merge、ViewStub的作用"><a href="#Include、Merge、ViewStub的作用" class="headerlink" title="Include、Merge、ViewStub的作用"></a>Include、Merge、ViewStub的作用</h3><p><strong>Include</strong>：布局重用</p><ul><li><p><code>&lt;include /&gt;</code>标签可以使用单独的layout属性，这个也是必须使用的。</p></li><li><p>可以使用其他属性。<code>&lt;include /&gt;</code>标签若指定了ID属性，而你的layout也定义了ID，则你的layout的ID会被覆盖，解决方案。</p></li><li><p>在<code>&lt;include /&gt;</code>标签中所有的<code>android:layout_*</code>都是有效的，<strong>前提是必须要写layout_width和layout_height两个属性</strong>。</p></li><li><p>布局中可以包含两个相同的include标签</p></li></ul><p><strong>Merge</strong>：减少视图层级，多用于替换FrameLayout或者当一个布局包含另一个时，<code>&lt;merge/&gt;</code>标签消除视图层次结构中多余的视图组。</p><blockquote><p>例如：你的主布局文件是垂直布局，引入了一个垂直布局的include，这是如果include布局使用的LinearLayout就没意义了，使用的话反而减慢你的UI表现。这时可以使用<merge>标签优化。</merge></p></blockquote><p><strong>ViewStub</strong>：需要时使用。优点是当你需要时才会加载，使用他并不会影响UI初始化时的性能。需要使用时调用<code>inflate()</code>。</p><hr><h3 id="Asset目录与res目录的区别"><a href="#Asset目录与res目录的区别" class="headerlink" title="Asset目录与res目录的区别"></a>Asset目录与res目录的区别</h3><ul><li><p><strong>assets 目录</strong>：不会在<code>R.java</code>文件下生成相应的标记，assets文件夹可以自己创建文件夹，必须使用<code>AssetsManager</code>类进行访问，存放到这里的资源在运行打包的时候都会打入程序安装包中，</p></li><li><p><strong>res 目录</strong>：会在R.java文件下生成标记，这里的资源会在运行打包操作的时候判断哪些被使用到了，没有被使用到的文件资源是不会打包到安装包中的。</p></li></ul><blockquote><p>res/raw 和 assets文件夹来存放不需要系统编译成二进制的文件，例如字体文件等</p><p>res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹</p></blockquote><hr><h3 id="System-gc-amp-amp-Runtime-gc"><a href="#System-gc-amp-amp-Runtime-gc" class="headerlink" title="System.gc &amp;&amp; Runtime.gc"></a>System.gc &amp;&amp; Runtime.gc</h3><p><code>System.gc</code>和<code>Runtime.gc</code>是等效的，在<code>System.gc</code>内部也是调用的<code>Runtime.gc</code>。<strong>调用两者都是通知虚拟机要进行gc，但是否立即回收还是延迟回收由JVM决定</strong>。两者唯一的区别就是一个是类方法，一个是实例方法。</p><hr><h3 id="Application-在多进程下会多次调用-onCreate-么？"><a href="#Application-在多进程下会多次调用-onCreate-么？" class="headerlink" title="Application 在多进程下会多次调用 onCreate() 么？"></a>Application 在多进程下会多次调用 onCreate() 么？</h3><p>当采用多进程的时候，比如下面的Service 配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".MyService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:process</span>=<span class="string">":remote"</span> /&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>android:process 属性中 <code>:</code>的作用就是把这个名字附加到你的包所运行的标准进程名字的后面作为新的进程名称。</p></blockquote><p>这样配置会调用 onCreate() 两次。</p><hr><h3 id="Theme-amp-amp-Style"><a href="#Theme-amp-amp-Style" class="headerlink" title="Theme &amp;&amp; Style"></a>Theme &amp;&amp; Style</h3><ul><li><p><strong>Style</strong> 是一组外观、样式的属性集合，适用于 View 和 Window 。</p></li><li><p><strong>Theme</strong> 是一种应用于整个 Activity 或者 Application ，而不是独立的 View。</p></li></ul><hr><h3 id="SQLiteOpenHelper-onCreate-调用时机？"><a href="#SQLiteOpenHelper-onCreate-调用时机？" class="headerlink" title="SQLiteOpenHelper.onCreate() 调用时机？"></a>SQLiteOpenHelper.onCreate() 调用时机？</h3><p>在调<code>getReadableDatabase</code>或<code>getWritableDatabase</code>时，会判断指定的数据库是否存在，不存在则调<code>SQLiteDatabase.onCreate</code>创建， <code>onCreate</code>只在数据库第一次创建时才执行。</p><hr><h3 id="Removecallback-失效？"><a href="#Removecallback-失效？" class="headerlink" title="Removecallback 失效？"></a>Removecallback 失效？</h3><p>Removecallback 必须是同一个Handler才能移除。</p><hr><h3 id="Toast-如果会短时间内频繁显示怎么优化？"><a href="#Toast-如果会短时间内频繁显示怎么优化？" class="headerlink" title="Toast 如果会短时间内频繁显示怎么优化？"></a>Toast 如果会短时间内频繁显示怎么优化？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void update(String msg)&#123;</span><br><span class="line">  toast.setText(msg);</span><br><span class="line">  toast.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Notification-如何优化？"><a href="#Notification-如何优化？" class="headerlink" title="Notification 如何优化？"></a>Notification 如何优化？</h3><p>可以通过 相同 ID 来更新 Notification 。</p><hr><h3 id="应用怎么判断自己是处于前台还是后台？"><a href="#应用怎么判断自己是处于前台还是后台？" class="headerlink" title="应用怎么判断自己是处于前台还是后台？"></a>应用怎么判断自己是处于前台还是后台？</h3><p>主要是通过 <code>getRunningAppProcesses()</code> 方法来实现。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">List&lt;ActivityManager.RunningAppProcessInfo&gt; appProcesses = activityManager.getRunningAppProcesses();</span><br><span class="line">for (ActivityManager.RunningAppProcessInfo appProcess : appProcesses) &#123;</span><br><span class="line">    if (appProcess.processName.equals(getPackageName())) &#123;</span><br><span class="line">        if (appProcess.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) &#123;</span><br><span class="line">            Log.d(TAG, String.format(&quot;Foreground App:%s&quot;, appProcess.processName));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Log.d(TAG, &quot;Background App:&quot; + appProcess.processName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="FragmentPagerAdapter-和-FragmentStateAdapter-的区别？"><a href="#FragmentPagerAdapter-和-FragmentStateAdapter-的区别？" class="headerlink" title="FragmentPagerAdapter 和 FragmentStateAdapter 的区别？"></a>FragmentPagerAdapter 和 FragmentStateAdapter 的区别？</h3><p><code>FragmentStatePagerAdapter</code> 是 <code>PagerAdapter</code> 的子类，这个适配器对实现多个 <code>Fragment</code> 界面的滑动是非常有用的，它的工作方式和listview是非常相似的。当Fragment对用户不可见的时候，整个Fragment会被销毁，只会保存Fragment的保存状态。基于这样的特性，<code>FragmentStatePagerAdapter</code> 比 <code>FragmentPagerAdapter</code> 更适合用于很多界面之间的转换，而且消耗更少的内存资源。</p><hr><h3 id="Bitmap的本质？"><a href="#Bitmap的本质？" class="headerlink" title="Bitmap的本质？"></a>Bitmap的本质？</h3><p>本质是 SkBitmap 详见 Pocket</p><hr><h3 id="SurfaceView-amp-amp-View-amp-amp-GLSurfaceView"><a href="#SurfaceView-amp-amp-View-amp-amp-GLSurfaceView" class="headerlink" title="SurfaceView &amp;&amp; View &amp;&amp; GLSurfaceView"></a>SurfaceView &amp;&amp; View &amp;&amp; GLSurfaceView</h3><ul><li><p><code>View</code>：显示视图，内置画布，提供图形绘制函数、触屏事件、按键事件函数等；<strong>必须在UI主线程内更新画面，速度较慢</strong>。</p></li><li><p><code>SurfaceView</code>：基于view视图进行拓展的视图类，更适合2D游戏的开发；<strong>View的子类，类似使用双缓机制，在新的线程（也可以在UI线程）中更新画面所以刷新界面速度比 View 快</strong>，但是会涉及到线程同步问题。</p></li></ul><p>　- <code>GLSurfaceView</code>：openGL专用。基于SurfaceView视图再次进行拓展的视图类，<strong>专用于3D游戏开发的视图</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;APK安装过程&quot;&gt;&lt;a href=&quot;#APK安装过程&quot; class=&quot;headerlink&quot; title=&quot;APK安装过程&quot;&gt;&lt;/a&gt;APK安装过程&lt;/h3&gt;&lt;p&gt;应用安装涉及到如下几个目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;system/app&lt;/strong&gt;：系统自带的应用程序，无法删除&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;data/app&lt;/strong&gt;：用户程序安装的目录，有删除权限。安装时把apk文件复制到此目录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;data/data&lt;/strong&gt;：存放应用程序的数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;data/dalvik-cache&lt;/strong&gt;：将apk中的dex文件安装到dalvik-cache目录下&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;复制APK安装包到data/app目录下，解压并扫描安装包，把dex文件(Dalvik字节码)保存到dalvik-cache目录，并在data/data目录下创建对应的应用数据目录。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;invalidate-和postInvalidate-的区别&quot;&gt;&lt;a href=&quot;#invalidate-和postInvalidate-的区别&quot; class=&quot;headerlink&quot; title=&quot;invalidate()和postInvalidate() 的区别&quot;&gt;&lt;/a&gt;invalidate()和postInvalidate() 的区别&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;invalidate()&lt;/code&gt;是用来刷新View的，必须是在UI线程中进行工作。比如在修改某个view的显示时，调用invalidate()才能看到重新绘制的界面。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postInvalidate()&lt;/code&gt;在工作者线程中被调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;导入外部数据库&quot;&gt;&lt;a href=&quot;#导入外部数据库&quot; class=&quot;headerlink&quot; title=&quot;导入外部数据库&quot;&gt;&lt;/a&gt;导入外部数据库&lt;/h3&gt;&lt;p&gt;Android系统下数据库应该存放在 &lt;code&gt;/data/data/com.*.*(package name)/&lt;/code&gt; 目录下，所以我们需要做的是把已有的数据库传入那个目录下。操作方法是用&lt;code&gt;FileInputStream&lt;/code&gt;读取原数据库，再用&lt;code&gt;FileOutputStream&lt;/code&gt;把读取到的东西写入到那个目录。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="面试题" scheme="http://www.yangxiaozong.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ListView原理及优化</title>
    <link href="http://www.yangxiaozong.com/ListView%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96.html"/>
    <id>http://www.yangxiaozong.com/ListView原理及优化.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.222Z</updated>
    
    <content type="html"><![CDATA[<p>##原理</p><p>ListView的实现离不开Adapter。可以这么理解：ListView中给出了数据来的时候，View如何实现的具体方式，相当于MVC中的V；而Adapter提供了相当于MVC中的C，指挥了ListView的数据加载等行为。</p><p>提一个问题：假设ListView中有10W个条项，那内存中会缓存10W个吗？答案当然是否定的。那么是如何实现的呢？下面这张图可以清晰地解释其中的原理:</p><p><img src="images/android-listview.jpg" alt=""><br><a id="more"></a><br>可以看到当一个View移出可视区域的时候，设为View1，它会被标记Recycle，然后可能：</p><ul><li>新进入的View2与View1类型相同，那么在getView方法传入的convertView就不是null而就是View1。换句话说，View1被重用了</li><li>新进入的View2与View1类型不同，那么getView传入的convertView就是null，这是需要new一个View。当内存紧张时，View1就会被GC</li></ul><h2 id="ListView的优化-以异步加载Bitmap优化为例"><a href="#ListView的优化-以异步加载Bitmap优化为例" class="headerlink" title="ListView的优化(以异步加载Bitmap优化为例)"></a>ListView的优化(以异步加载Bitmap优化为例)</h2><p>首先概括的说ListView优化分为三级缓存:</p><ul><li>内存缓存</li><li>文件缓存</li><li>网络读取</li></ul><p>简要概括就是在getView中，如果加载过一个图片，放入Map类型的一个MemoryCache中(示例代码使用的是Collections.synchronizedMap(new LinkedHashMap<string, bitmap="">(10, 1.5f, true))来维护一个试用LRU的堆)。如果这里获取不到，根据View被Recycle之前放入的TAG中记录的uri从文件系统中读取文件缓存。如果本地都找不到，再去网络中异步加载。</string,></p><p>这里有几个注意的优化点：</p><ul><li>从文件系统中加载图片也没有内存中加载那么快，甚至可能内存中加载也不够快。因此在ListView中应设立busy标志位，当ListView滚动时busy设为true，停止各个view的图片加载。否则可能会让UI不够流畅用户体验度降低。</li><li>文件加载图片放在子线程实现，否则快速滑动屏幕会卡</li><li>开启网络访问等耗时操作需要开启新线程，应使用线程池避免资源浪费，最起码也要用AsyncTask。</li><li>Bitmap从网络下载下来最好先放到文件系统中缓存。这样一是方便下一次加载根据本地uri直接找到，二是如果Bitmap过大，从本地缓存可以方便的使用Option.inSampleSize配合Bitmap.decodeFile(ui, options)或Bitmap.createScaledBitmap来进行内存压缩</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##原理&lt;/p&gt;
&lt;p&gt;ListView的实现离不开Adapter。可以这么理解：ListView中给出了数据来的时候，View如何实现的具体方式，相当于MVC中的V；而Adapter提供了相当于MVC中的C，指挥了ListView的数据加载等行为。&lt;/p&gt;
&lt;p&gt;提一个问题：假设ListView中有10W个条项，那内存中会缓存10W个吗？答案当然是否定的。那么是如何实现的呢？下面这张图可以清晰地解释其中的原理:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/android-listview.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="ListView" scheme="http://www.yangxiaozong.com/tags/ListView/"/>
    
  </entry>
  
  <entry>
    <title>性能优化</title>
    <link href="http://www.yangxiaozong.com/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html"/>
    <id>http://www.yangxiaozong.com/性能优化.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a>ANR</h2><p>ANR全称<code>Application Not Responding</code>，意思就是程序未响应。</p><h3 id="出现场景"><a href="#出现场景" class="headerlink" title="出现场景"></a>出现场景</h3><ul><li>主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。</li><li>主线程中存在耗时的计算</li><li>主线程中错误的操作，比如Thread.wait或者Thread.sleep等</li></ul><p>Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框</p><ul><li>应用在5秒内未响应用户的输入事件（如按键或者触摸）</li><li>BroadcastReceiver未在10秒内完成相关的处理</li></ul><h3 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h3><a id="more"></a><p>基本的思路就是将IO操作在工作线程来处理，减少其他耗时操作和错误操作</p><ul><li>使用AsyncTask处理耗时IO操作。</li><li>使用Thread或者HandlerThread时，调用<code>Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)</code>设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。</li><li>使用Handler处理工作线程结果，而不是使用Thread.wait()或者Thread.sleep()来阻塞主线程。</li><li><code>Activity</code>的<code>onCreate</code>和<code>onResume</code>回调中尽量避免耗时的代码</li><li><code>BroadcastReceiver</code>中<code>onReceive</code>代码也要尽量减少耗时，建议使用<code>IntentService</code>处理。</li></ul><h3 id="如何改善"><a href="#如何改善" class="headerlink" title="如何改善"></a>如何改善</h3><p>通常100到200毫秒就会让人察觉程序反应慢，为了更加提升响应，可以使用下面的几种方法</p><ul><li>如果程序正在后台处理用户的输入，建议使用让用户得知进度，比如使用ProgressBar控件。</li><li>程序启动时可以选择加上欢迎界面，避免让用户察觉卡顿。</li><li>使用<code>Systrace</code>和<code>TraceView</code>找出影响响应的问题。</li></ul><p>如果开发机器上出现问题，我们可以通过查看<code>/data/anr/traces.txt</code>即可，最新的ANR信息在最开始部分。</p><h2 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h2><p>在实践操作当中，可以从四个方面着手减小内存使用，首先是减小对象的内存占用，其次是内存对象的重复利用，然后是避免对象的内存泄露，最后是内存使用策略优化。</p><h3 id="减小对象的内存占用"><a href="#减小对象的内存占用" class="headerlink" title="减小对象的内存占用"></a>减小对象的内存占用</h3><ul><li><p><code>使用更加轻量级的数据结构</code>：例如，我们可以考虑使用<code>ArrayMap</code>/<code>SparseArray</code>而不是<code>HashMap</code>等传统数据结构，相比起Android系统专门为移动操作系统编写的<code>ArrayMap</code>容器，在大多数情况下，<code>HashMap</code>都显示效率低下，更占内存。另外，<code>SparseArray</code>更加高效在于，<strong>避免了对key与value的自动装箱，并且避免了装箱后的解箱</strong>。</p></li><li><p><code>避免使用Enum</code>：在Android中应该尽量使用<code>int</code>来代替<code>Enum</code>，因为使用<code>Enum</code>会导致编译后的dex文件大小增大，并且使用<code>Enum</code>时，其运行时还会产生额外的内存占用。</p></li><li><p><code>减小</code>Bitmap<code>对象的内存占用</code>：</p><ul><li><p><code>inBitmap</code>：如果设置了这个字段，Bitmap在加载数据时可以复用这个字段所指向的bitmap的内存空间。<strong>但是，内存能够复用也是有条件的。比如，在<code>Android 4.4(API level 19)</code>之前，只有新旧两个Bitmap的尺寸一样才能复用内存空间。<code>Android 4.4</code>开始只要旧 Bitmap 的尺寸大于等于新的 Bitmap 就可以复用了</strong>。</p></li><li><p><code>inSampleSize</code>：缩放比例，在把图片载入内存之前，我们需要先计算出一个合适的缩放比例，避免不必要的大图载入。</p></li><li><p><code>decode format</code>：解码格式，选择<code>ARGB_8888</code> <code>RBG_565</code> <code>ARGB_4444</code> <code>ALPHA_8</code>，存在很大差异。</p><blockquote><p>ARGB_4444：每个像素占四位，即A=4，R=4，G=4，B=4，那么一个像素点占4+4+4+4=16位<br>ARGB_8888：每个像素占四位，即A=8，R=8，G=8，B=8，那么一个像素点占8+8+8+8=32位<br>RGB_565：每个像素占四位，即R=5，G=6，B=5，没有透明度，那么一个像素点占5+6+5=16位<br>ALPHA_8：每个像素占四位，只有透明度，没有颜色。</p></blockquote></li></ul></li><li><p><code>使用更小的图片</code>：在设计给到资源图片的时候，我们需要特别留意这张图片是否存在可以压缩的空间，是否可以使用一张更小的图片。<strong>尽量使用更小的图片不仅仅可以减少内存的使用，还可以避免出现大量的InflationException</strong>。假设有一张很大的图片被XML文件直接引用，很有可能在初始化视图的时候就会因为内存不足而发生InflationException，这个问题的根本原因其实是发生了OOM。</p></li></ul><h3 id="内存对象的重复使用"><a href="#内存对象的重复使用" class="headerlink" title="内存对象的重复使用"></a>内存对象的重复使用</h3><p>大多数对象的复用，最终实施的方案都是利用对象池技术，要么是在编写代码的时候显式的在程序里面去创建对象池，然后处理好复用的实现逻辑，要么就是利用系统框架既有的某些复用特性达到减少对象的重复创建，从而减少内存的分配与回收。</p><ul><li><p><code>复用系统自带资源</code>：Android系统本身内置了很多的资源，例如字符串/颜色/图片/动画/样式以及简单布局等等，这些资源都可以在应用程序中直接引用。<strong>这样做不仅仅可以减少应用程序的自身负重，减小APK的大小，另外还可以一定程度上减少内存的开销，复用性更好</strong>。但是也有必要留意Android系统的版本差异性，对那些不同系统版本上表现存在很大差异，不符合需求的情况，还是需要应用程序自身内置进去。</p></li><li><p><code>ListView ViewHodler</code></p></li><li><p><code>Bitmap对象的复用</code>：在ListView与GridView等显示大量图片的控件里面需要使用LRU的机制来缓存处理好的Bitmap。</p></li><li><p><code>inBitmap</code>：<strong>使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域</strong>，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的<code>pixel data</code>内存区域，而不是去问内存重新申请一块区域来存放bitmap。</p><blockquote><ul><li>使用inBitmap，在4.4之前，只能重用相同大小的bitmap的内存区域，而4.4之后你可以重用任何bitmap的内存区域，只要这块内存比将要分配内存的bitmap大就可以。这里最好的方法就是使用LRUCache来缓存bitmap，后面来了新的bitmap，可以从cache中按照api版本找到最适合重用的bitmap，来重用它的内存区域。</li><li>新申请的bitmap与旧的bitmap必须有相同的解码格式</li></ul></blockquote></li><li><p>避免在onDraw方法里面执行对象的创建：类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。</p></li><li><p><code>StringBuilder</code>：在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</p></li></ul><h3 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h3><ul><li><code>内部类引用导致Activity的泄漏</code>：最典型的场景是Handler导致的Activity泄漏，如果Handler中有延迟的任务或者是等待执行的任务队列过长，都有可能因为Handler继续执行而导致Activity发生泄漏。</li><li><code>Activity Context被传递到其他实例中，这可能导致自身被引用而发生泄漏</code>。</li><li>考虑使用Application Context而不是Activity Context</li><li>注意临时Bitmap对象的及时回收</li><li>注意监听器的注销</li><li>注意缓存容器中的对象泄漏：不使用的对象要将引用置空。</li><li>注意Cursor对象是否及时关闭</li></ul><h3 id="内存优化策略"><a href="#内存优化策略" class="headerlink" title="内存优化策略"></a>内存优化策略</h3><ul><li><p>综合考虑设备内存阈值与其他因素设计合适的缓存大小</p></li><li><p><code>onLowMemory()</code>：Android系统提供了一些回调来通知当前应用的内存使用情况，通常来说，当所有的background应用都被kill掉的时候，forground应用会收到onLowMemory()的回调。在这种情况下，需要尽快释放当前应用的非必须的内存资源，从而确保系统能够继续稳定运行。</p></li><li><p><code>onTrimMemory()</code>：Android系统从4.0开始还提供了onTrimMemory()的回调，当系统内存达到某些条件的时候，所有正在运行的应用都会收到这个回调，同时在这个回调里面会传递以下的参数，代表不同的内存使用情况，收到onTrimMemory()回调的时候，需要根据传递的参数类型进行判断，合理的选择释放自身的一些内存占用，一方面可以提高系统的整体运行流畅度，另外也可以避免自己被系统判断为优先需要杀掉的应用</p></li><li><p>资源文件需要选择合适的文件夹进行存放：例如我们只在<code>hdpi</code>的目录下放置了一张100100的图片，那么根据换算关系，<code>xxhdpi</code>的手机去引用那张图片就会被拉伸到200200。需要注意到在这种情况下，内存占用是会显著提高的。<strong>对于不希望被拉伸的图片，需要放到assets或者nodpi的目录下</strong>。</p></li><li><p>谨慎使用static对象</p></li><li><p>优化布局层次，减少内存消耗</p></li><li><p>使用FlatBuffer等工具序列化数据</p></li><li><p>谨慎使用依赖注入框架</p></li><li><p>使用ProGuard来剔除不需要的代码</p></li></ul><h2 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h2><p>导致Android界面滑动卡顿主要有两个原因：</p><ul><li><p>UI线程（main）有耗时操作</p></li><li><p>视图渲染时间过长，导致卡顿</p></li></ul><p>众所周知，界面的流畅度主要依赖<code>FPS</code>这个值，这个值是通过（1s/渲染1帧所花费的时间）计算所得，FPS值越大视频越流畅，所以就需要渲染1帧的时间能尽量缩短。<strong>正常流畅度的FPS值在60左右，即渲染一帧的时间不应大于16 ms</strong>。</p><p>如果想让应用流畅运行 ：</p><ul><li>不要阻塞UI线程；</li><li>不要在UI线程之外操作UI；</li><li>减少UI嵌套层级</li></ul><p><strong>针对界面切换卡顿，一般出现在组件初始化的地方。屏幕滑动卡顿，ui嵌套层级，还有图片加载，图片的话，滑动不加载，监听scrollListener</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ANR&quot;&gt;&lt;a href=&quot;#ANR&quot; class=&quot;headerlink&quot; title=&quot;ANR&quot;&gt;&lt;/a&gt;ANR&lt;/h2&gt;&lt;p&gt;ANR全称&lt;code&gt;Application Not Responding&lt;/code&gt;，意思就是程序未响应。&lt;/p&gt;
&lt;h3 id=&quot;出现场景&quot;&gt;&lt;a href=&quot;#出现场景&quot; class=&quot;headerlink&quot; title=&quot;出现场景&quot;&gt;&lt;/a&gt;出现场景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;主线程被IO操作（从4.0之后网络IO不允许在主线程中）阻塞。&lt;/li&gt;
&lt;li&gt;主线程中存在耗时的计算&lt;/li&gt;
&lt;li&gt;主线程中错误的操作，比如Thread.wait或者Thread.sleep等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Android系统会监控程序的响应状况，一旦出现下面两种情况，则弹出ANR对话框&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用在5秒内未响应用户的输入事件（如按键或者触摸）&lt;/li&gt;
&lt;li&gt;BroadcastReceiver未在10秒内完成相关的处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;如何避免&quot;&gt;&lt;a href=&quot;#如何避免&quot; class=&quot;headerlink&quot; title=&quot;如何避免&quot;&gt;&lt;/a&gt;如何避免&lt;/h3&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="性能优化" scheme="http://www.yangxiaozong.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>推送机制</title>
    <link href="http://www.yangxiaozong.com/%E6%8E%A8%E9%80%81%E6%9C%BA%E5%88%B6.html"/>
    <id>http://www.yangxiaozong.com/推送机制.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h2><p>客户端隔一段时间就去服务器上获取一下信息，看是否有更新的信息出现，这就是轮询。我们可以通过<code>AlarmManager</code>来管理时间，当然时间的设置策略也是十分重要的，由于每次轮询都需要建立和释放TCP连接，所以在移动网络情况下耗电量相当大。</p><p><img src="images/android-radio-state.png" alt=""></p><blockquote><p>移动网络状态转换</p></blockquote><p>针对不同应用的需求，有的可以每5分钟查询一次或者每10分钟查询一次，但是这种策略的电量和流量消耗十分严重。我们可以使用退避法（暂时这么说），比如第一次我们每隔2分钟查询一次数据，如果没有数据，就将查询间隔加倍。</p><p>同时进程的保活也十分重要，这部分的知识参照<a href="keep-live。md">进程保活</a>。<br><a id="more"></a></p><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>客户端主动和服务器建立TCP长连接之后，客户端定期向服务器发送心跳包，有消息的时候，服务器直接通过这个已经建立好的TCP连接通知客户端。</p><p>长连接就是 <strong>建立连接之后，不主动断开。双方互相发送数据，发完了也不主动断开连接，之后有需要发送的数据就继续通过这个连接发送</strong>。</p><h3 id="影响TCP连接寿命的因素"><a href="#影响TCP连接寿命的因素" class="headerlink" title="影响TCP连接寿命的因素"></a>影响TCP连接寿命的因素</h3><h4 id="NAT超时"><a href="#NAT超时" class="headerlink" title="NAT超时"></a>NAT超时</h4><p>因为 IPv4 的 IP 量有限，运营商分配给手机终端的 IP 是运营商内网的 IP，手机要连接 Internet，就需要通过运营商的网关做一个网络地址转换（Network Address Translation，NAT）。简单的说运营商的网关需要维护一个外网 IP、端口到内网 IP、端口的对应关系，以确保内网的手机可以跟 Internet 的服务器通讯。</p><p><img src="images/push-nat.jpg" alt=""></p><blockquote><p>NAT 功能由图中的 GGSN 模块实现。</p></blockquote><p>大部分移动无线网络运营商都在链路一段时间没有数据通讯时，会淘汰 NAT 表中的对应项，造成链路中断。</p><h4 id="DHCP租期"><a href="#DHCP租期" class="headerlink" title="DHCP租期"></a>DHCP租期</h4><p>目前测试发现安卓系统对DHCP的处理有Bug，DHCP租期到了不会主动续约并且会继续使用过期IP，这个问题会造成TCP长连接偶然的断连。</p><h4 id="网络状态变化"><a href="#网络状态变化" class="headerlink" title="网络状态变化"></a>网络状态变化</h4><p>手机网络和WIFI网络切换、网络断开和连上等情况有网络状态的变化，也会使长连接变为无效连接，需要监听响应的网络状态变化事件，重新建立Push长连接。</p><h3 id="心跳包"><a href="#心跳包" class="headerlink" title="心跳包"></a>心跳包</h3><p>TCP长连接本质上不需要心跳包来维持，其主要是为了防止上面提到的NAT超时，既然一些<code>NAT设备</code>判断是否淘汰<code>NAT映射</code>的依据是一定时间没有数据，那么客户端就主动发一个数据，这样就能维持TCP长连接。</p><p>当然，如果仅仅是为了防止NAT超时，可以让服务器来发送心跳包给客户端，不过这样做有个弊病就是，万一连接断了，服务器就再也联系不上客户端了。所以心跳包必须由客户端发送，客户端发现连接断了，还可以尝试重连服务器。</p><h4 id="时间间隔"><a href="#时间间隔" class="headerlink" title="时间间隔"></a>时间间隔</h4><p>发送心跳包势必要先唤醒设备，然后才能发送，如果唤醒设备过于频繁，或者直接导致设备无法休眠，会大量消耗电量，而且移动网络下进行网络通信，比在wifi下耗电得多。所以这个心跳包的时间间隔应该尽量的长，最理想的情况就是根本没有NAT超时，比如刚才我说的两台在同一个wifi下的电脑，完全不需要心跳包。这也就是网上常说的长连接，慢心跳。</p><p>现实是残酷的，根据网上的一些说法，中移动2/3G下，NAT超时时间为5分钟，中国电信3G则大于28分钟，理想的情况下，客户端应当以略小于NAT超时时间的间隔来发送心跳包。</p><h4 id="心跳包和轮询的区别"><a href="#心跳包和轮询的区别" class="headerlink" title="心跳包和轮询的区别"></a>心跳包和轮询的区别</h4><ul><li>轮询是为了获取数据，而心跳是为了保活TCP连接。</li><li>轮询得越频繁，获取数据就越及时，心跳的频繁与否和数据是否及时没有直接关系。</li><li>轮询比心跳能耗更高，因为一次轮询需要经过TCP三次握手，四次挥手，单次心跳不需要建立和拆除TCP连接。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;轮询&quot;&gt;&lt;a href=&quot;#轮询&quot; class=&quot;headerlink&quot; title=&quot;轮询&quot;&gt;&lt;/a&gt;轮询&lt;/h2&gt;&lt;p&gt;客户端隔一段时间就去服务器上获取一下信息，看是否有更新的信息出现，这就是轮询。我们可以通过&lt;code&gt;AlarmManager&lt;/code&gt;来管理时间，当然时间的设置策略也是十分重要的，由于每次轮询都需要建立和释放TCP连接，所以在移动网络情况下耗电量相当大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/android-radio-state.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;移动网络状态转换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;针对不同应用的需求，有的可以每5分钟查询一次或者每10分钟查询一次，但是这种策略的电量和流量消耗十分严重。我们可以使用退避法（暂时这么说），比如第一次我们每隔2分钟查询一次数据，如果没有数据，就将查询间隔加倍。&lt;/p&gt;
&lt;p&gt;同时进程的保活也十分重要，这部分的知识参照&lt;a href=&quot;keep-live。md&quot;&gt;进程保活&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="推送" scheme="http://www.yangxiaozong.com/tags/%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Android广播机制</title>
    <link href="http://www.yangxiaozong.com/Android%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6.html"/>
    <id>http://www.yangxiaozong.com/Android广播机制.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.231Z</updated>
    
    <content type="html"><![CDATA[<p>广播(Broadcast)机制用于进程/线程间通信，广播分为广播发送和广播接收两个过程，其中广播接收者BroadcastReceiver便是Android四大组件之一。</p><p>BroadcastReceiver分为两类：</p><ul><li><code>静态广播接收者</code>：通过<code>AndroidManifest.xml</code>的标签来申明的BroadcastReceiver。</li><li><p><code>动态广播接收者</code>：通过<code>AMS.registerReceiver()</code>方式注册的BroadcastReceiver，动态注册更为灵活，可在不需要时通过<code>unregisterReceiver()</code>取消注册。</p><a id="more"></a><p>从广播发送方式可分为三类：</p></li><li><p><code>普通广播</code>：通过Context.sendBroadcast()发送，可并行处理</p></li><li><code>有序广播</code>：通过Context.sendOrderedBroadcast()发送，串行处理</li><li><code>Sticky广播</code>：通过Context.sendStickyBroadcast()发送，发出的广播会一直滞留（等待），以便有人注册这则广播消息后能尽快的收到这条广播。</li></ul><p>Android 中的 Broadcast 实际底层使用Binder机制。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;广播(Broadcast)机制用于进程/线程间通信，广播分为广播发送和广播接收两个过程，其中广播接收者BroadcastReceiver便是Android四大组件之一。&lt;/p&gt;
&lt;p&gt;BroadcastReceiver分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;静态广播接收者&lt;/code&gt;：通过&lt;code&gt;AndroidManifest.xml&lt;/code&gt;的标签来申明的BroadcastReceiver。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;动态广播接收者&lt;/code&gt;：通过&lt;code&gt;AMS.registerReceiver()&lt;/code&gt;方式注册的BroadcastReceiver，动态注册更为灵活，可在不需要时通过&lt;code&gt;unregisterReceiver()&lt;/code&gt;取消注册。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="广播" scheme="http://www.yangxiaozong.com/tags/%E5%B9%BF%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>Activity四种启动模式</title>
    <link href="http://www.yangxiaozong.com/Activity%E5%9B%9B%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://www.yangxiaozong.com/Activity四种启动模式.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h2><p>标准模式。每次启动Activity都会创建新的实例。<strong>谁启动了这个Activity，那么这个Activity就运行在谁的Task中</strong>。不能使用非Activity类型的<code>context</code>启动这种模式的Activity，因为这种<code>context</code>并没有Task，这个时候就可以加一个<code>FLAG_ACTIVITY_NEW_TASK</code>标记位，这个时候启动Activity实际上是以singleTask模式启动。</p><p><img src="images/android-lanchmode-standard.gif" alt=""></p><h2 id="SingleTop"><a href="#SingleTop" class="headerlink" title="SingleTop"></a>SingleTop</h2><a id="more"></a><p>栈顶复用模式。如果当前栈顶是要启动的Activity，那么直接引用，如果不是，则新建。在直接引用的时候会调用<code>onNewIntent()</code>方法。</p><p><img src="images/android-lanchmode-singletop.gif" alt=""></p><p>适合接收通知启动的内容显示页面，或者从外界可能多次跳转到一个界面。</p><h2 id="SingleTask"><a href="#SingleTask" class="headerlink" title="SingleTask"></a>SingleTask</h2><p>栈内复用模式。这种模式下，只要Activity只要在一个栈内存在，那么就不会创建新的实例，会调用<code>onNewIntent()</code>方法。</p><ul><li><p>如果要调用的Activity在同一应用中：调用singleTask模式的Activity会清空在它之上的所有Activity。</p></li><li><p>若其他应用启动该Activity：如果不存在，则建立新的Task。如果已经存在后台，那么启动后，后台的Task会一起被切换到前台。</p></li></ul><p><img src="images/android-lanchmode-singletask.gif" alt=""></p><p>适合作为程序入口点，例如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</p><h2 id="SingleInstance"><a href="#SingleInstance" class="headerlink" title="SingleInstance"></a>SingleInstance</h2><p>单实例模式。这时一种加强的singleTask，它除了具有singleTask的所有特性外，还加强了一点–该模式的Activity只能单独的位于一个Task中。</p><blockquote><p>不同Task之间，默认不能传递数据(<code>startActivityForResult()</code>)，如果一定要传递，只能使用Intent绑定。</p></blockquote><p><img src="images/android-lanchmode-singleinstance.gif" alt=""></p><p>适合需要与程序分离开的页面。例如闹铃提醒，将闹铃提醒与闹铃设置分离。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Standard&quot;&gt;&lt;a href=&quot;#Standard&quot; class=&quot;headerlink&quot; title=&quot;Standard&quot;&gt;&lt;/a&gt;Standard&lt;/h2&gt;&lt;p&gt;标准模式。每次启动Activity都会创建新的实例。&lt;strong&gt;谁启动了这个Activity，那么这个Activity就运行在谁的Task中&lt;/strong&gt;。不能使用非Activity类型的&lt;code&gt;context&lt;/code&gt;启动这种模式的Activity，因为这种&lt;code&gt;context&lt;/code&gt;并没有Task，这个时候就可以加一个&lt;code&gt;FLAG_ACTIVITY_NEW_TASK&lt;/code&gt;标记位，这个时候启动Activity实际上是以singleTask模式启动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;images/android-lanchmode-standard.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;SingleTop&quot;&gt;&lt;a href=&quot;#SingleTop&quot; class=&quot;headerlink&quot; title=&quot;SingleTop&quot;&gt;&lt;/a&gt;SingleTop&lt;/h2&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="Activity" scheme="http://www.yangxiaozong.com/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>进程保活</title>
    <link href="http://www.yangxiaozong.com/%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%B4%BB.html"/>
    <id>http://www.yangxiaozong.com/进程保活.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程生命周期"><a href="#进程生命周期" class="headerlink" title="进程生命周期"></a>进程生命周期</h2><p>Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要清除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。</p><p>重要性层次结构一共有 5 级。以下列表按照重要程度列出了各类进程（第一个进程最重要，将是最后一个被终止的进程）：</p><ol><li><p>前台进程：用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：</p><ul><li><p>托管用户正在交互的 Activity（已调用 Activity 的 <code>onResume()</code> 方法）</p></li><li><p>托管某个 Service，后者绑定到用户正在交互的 Activity</p></li><li><p>托管正在“前台”运行的 Service（服务已调用 <code>startForeground()</code>）</p></li><li><p>托管正执行一个生命周期回调的 Service（<code>onCreate()</code>、<code>onStart()</code> 或 <code>onDestroy()</code>）</p></li><li><p>托管正执行其 <code>onReceive()</code> 方法的 BroadcastReceiver</p></li></ul><p>通常，在任意给定时间前台进程都为数不多。只有在内在不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。</p><a id="more"></a></li><li><p>可见进程：没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：</p><ul><li><p>托管不在前台、但仍对用户可见的 Activity（已调用其 <code>onPause()</code> 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况</p></li><li><p>托管绑定到可见（或前台）Activity 的 Service</p></li></ul><p>可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。</p></li><li><p>服务进程：正在运行已使用 <code>startService()</code> 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。</p></li><li><p>后台进程：包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 <code>onStop()</code> 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。</p></li><li><p>空进程：不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。</p></li></ol><p><strong>根据进程中当前活动组件的重要程度，Android 会将进程评定为它可能达到的最高级别</strong>。例如，如果某进程托管着服务和可见 Activity，则会将此进程评定为可见进程，而不是服务进程。</p><p>此外，一个进程的级别可能会因其他进程对它的依赖而有所提高，即 <strong>服务于另一进程的进程其级别永远不会低于其所服务的进程</strong>。 例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。</p><p>由于运行服务的进程其级别高于托管后台 Activity 的进程，因此 <strong>启动长时间运行操作的 Activity 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 Activity 更加持久时尤要如此</strong>。例如，正在将图片上传到网站的 Activity 应该启动服务来执行上传，这样一来，即使用户退出 Activity，仍可在后台继续执行上传操作。使用服务可以保证，无论 Activity 发生什么情况，该操作至少具备“服务进程”优先级。 同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。</p><h2 id="保活的基本概念"><a href="#保活的基本概念" class="headerlink" title="保活的基本概念"></a>保活的基本概念</h2><p>当前Android进程保活手段主要分为 黑、白、灰 三种，其大致的实现思路如下：</p><ul><li><p><strong>黑色保活</strong>：不同的app进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒）</p></li><li><p><strong>白色保活</strong>：启动前台Service</p></li><li><p><strong>灰色保活</strong>：利用系统的漏洞启动前台Service</p></li></ul><blockquote><p>还有一种就是控制Service.onStartCommand的返回值，使用 <code>START_STICKY</code>可以在一定程度上保活。</p></blockquote><h2 id="黑色保活"><a href="#黑色保活" class="headerlink" title="黑色保活"></a>黑色保活</h2><p>所谓黑色保活，就是利用不同的app进程使用广播来进行相互唤醒。举个3个比较常见的场景：</p><ul><li><p><strong>场景1</strong>：开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒app。</p></li><li><p><strong>场景2</strong>：接入第三方SDK也会唤醒相应的app进程，如微信sdk会唤醒微信，支付宝sdk会唤醒支付宝。由此发散开去，就会直接触发了下面的场景3。</p></li><li><p><strong>场景3</strong>：假如你手机里装了支付宝、淘宝、天猫、UC等阿里系的app，那么你打开任意一个阿里系的app后，有可能就顺便把其他阿里系的app给唤醒了。</p></li></ul><h2 id="白色保活"><a href="#白色保活" class="headerlink" title="白色保活"></a>白色保活</h2><p>白色保活手段非常简单，就是调用系统api启动一个前台的Service进程，这样会在系统的通知栏生成一个Notification，用来让用户知道有这样一个app在运行着，哪怕当前的app退到了后台。如网易云音乐。</p><h2 id="灰色保活"><a href="#灰色保活" class="headerlink" title="灰色保活"></a>灰色保活</h2><p>它是利用系统的漏洞来启动一个前台的Service进程，与普通的启动方式区别在于，它不会在系统通知栏处出现一个Notification，看起来就如同运行着一个后台Service进程一样。这样做带来的好处就是，用户无法察觉到你运行着一个前台进程（因为看不到Notification）,但你的进程优先级又是高于普通后台进程的。</p><ul><li><p><code>API &lt; 18</code>，启动前台Service时直接传入new Notification()；</p></li><li><p><code>API &gt;= 18</code>，同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理；</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GrayService extends Service &#123;</span><br><span class="line"></span><br><span class="line">    private final static int GRAY_SERVICE_ID = 1001;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &lt; 18) &#123;</span><br><span class="line">            startForeground(GRAY_SERVICE_ID, new Notification());//API &lt; 18 ，此方法能有效隐藏Notification上的图标</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Intent innerIntent = new Intent(this, GrayInnerService.class);</span><br><span class="line">            startService(innerIntent);</span><br><span class="line">            startForeground(GRAY_SERVICE_ID, new Notification());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return super.onStartCommand(intent, flags, startId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 给 API &gt;= 18 的平台上用的灰色保活手段</span><br><span class="line">     */</span><br><span class="line">    public static class GrayInnerService extends Service &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int onStartCommand(Intent intent, int flags, int startId) &#123;</span><br><span class="line">            startForeground(GRAY_SERVICE_ID, new Notification());</span><br><span class="line">            stopForeground(true);</span><br><span class="line">            stopSelf();</span><br><span class="line">            return super.onStartCommand(intent, flags, startId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;进程生命周期&quot;&gt;&lt;a href=&quot;#进程生命周期&quot; class=&quot;headerlink&quot; title=&quot;进程生命周期&quot;&gt;&lt;/a&gt;进程生命周期&lt;/h2&gt;&lt;p&gt;Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要清除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。&lt;/p&gt;
&lt;p&gt;重要性层次结构一共有 5 级。以下列表按照重要程度列出了各类进程（第一个进程最重要，将是最后一个被终止的进程）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;前台进程：用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;托管用户正在交互的 Activity（已调用 Activity 的 &lt;code&gt;onResume()&lt;/code&gt; 方法）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;托管某个 Service，后者绑定到用户正在交互的 Activity&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;托管正在“前台”运行的 Service（服务已调用 &lt;code&gt;startForeground()&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;托管正执行一个生命周期回调的 Service（&lt;code&gt;onCreate()&lt;/code&gt;、&lt;code&gt;onStart()&lt;/code&gt; 或 &lt;code&gt;onDestroy()&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;托管正执行其 &lt;code&gt;onReceive()&lt;/code&gt; 方法的 BroadcastReceiver&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常，在任意给定时间前台进程都为数不多。只有在内在不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="进程" scheme="http://www.yangxiaozong.com/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Activity &amp;&amp; Service生命周期</title>
    <link href="http://www.yangxiaozong.com/Activity%20&amp;&amp;%20Service%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html"/>
    <id>http://www.yangxiaozong.com/Activity &amp;&amp; Service生命周期.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><p><img src="images/activity-basic-lifecycle.png" alt=""></p><p>在上面的图中存在不同状态之间的过渡，但是，这些状态中只有三种可以是静态，也就是说 Activity 只能在三种状态之一下存在很长时间。</p><ul><li><p><strong>继续</strong>：在这种状态下，Activity处于前台，且用户可以与其交互（又称为运行态，在调用 <code>onResume()</code> 方法调用后）。</p></li><li><p><strong>暂停</strong>：在这种状态下，Activity被在前台中处于半透明状态或者未覆盖整个屏幕的另一个Activity—部分阻挡。 暂停的Activity不会接收用户输入并且无法执行任何代码。</p></li><li><p><strong>停止</strong>：在这种状态下，Activity被完全隐藏并且对用户不可见；它被视为处于后台。 停止时，Activity实例及其诸如成员变量等所有状态信息将保留，但它无法执行任何代码。</p></li></ul><p>其他状态（“创建”和“开始”）是瞬态，系统会通过调用下一个生命周期回调方法从这些状态快速移到下一个状态。 也就是说，在系统调用 <code>onCreate()</code> 之后，它会快速调用 <code>onStart()</code>，紧接着快速调用 <code>onResume()</code>。</p><h3 id="创建和销毁"><a href="#创建和销毁" class="headerlink" title="创建和销毁"></a>创建和销毁</h3><a id="more"></a><h4 id="创建一个新实例"><a href="#创建一个新实例" class="headerlink" title="创建一个新实例"></a>创建一个新实例</h4><p>大多数应用包含若干个不同的Activity，用户可通过这些Activity执行不同的操作。无论Activity是用户单击您的应用图标时创建的主Activity还是您的应用在响应用户操作时开始的其他Activity，系统都会通过调用其 <code>onCreate()</code> 方法创建 Activity 的每个新实例。</p><p>一旦 <code>onCreate()</code> 完成执行操作，系统会相继调用 <code>onStart()</code> 和 <code>onResume()</code> 方法，您的Activity从不会驻留在“已创建”或“已开始”状态。在技术上，<strong>Activity会在 onStart() 被调用时变得可见，但紧接着是 onResume()，且Activity保持“运行”状态，直到有事情发生使其发生变化</strong>，比如当接听来电时，用户导航至另一个Activity，或设备屏幕关闭。</p><h4 id="销毁Activity"><a href="#销毁Activity" class="headerlink" title="销毁Activity"></a>销毁Activity</h4><p>当Activity的第一个生命周期回调是 <code>onCreate()</code> 时，它最终的回调是 <code>onDestroy()</code>。<strong>系统会对您的Activity调用此方法，作为Activity实例完全从系统内存删除的最终信号</strong>。</p><blockquote><p>在所有情况下，系统在调用 <code>onPause()</code> 和 <code>onStop()</code> 之后都会调用 <code>onDestroy()</code> ，只有一个例外：当您从 <code>onCreate()</code> 方法内调用 <code>finish()</code> 时。在有些情况下，比如当您的Activity作为临时决策工具运行以启动另一个Activity时，您可从 <code>onCreate()</code> 内调用 <code>finish()</code> 来销毁Activity。 在这种情况下，系统会立刻调用 <code>onDestroy()</code>，而不调用任何其他生命周期方法。</p></blockquote><h3 id="暂停和继续"><a href="#暂停和继续" class="headerlink" title="暂停和继续"></a>暂停和继续</h3><p>在正常使用应用的过程中，前台 Activity 有时会被其他导致 <em>Activity 暂停</em> 的可视组件阻挡。 例如，<strong>当半透明Activity打开时（比如对话框样式中的Activity），上一个Activity会暂停。只要 Activity 仍然部分可见但目前又未处于焦点之中，它会一直暂停。但是，一旦Activity完全被阻挡并且不可见，它便停止</strong>。</p><p>当 Activity 进入暂停状态时，系统会对调用 <code>onPause()</code> 方法，通过该方法，您可以停止不应在暂停时继续的进行之中的操作（比如视频）或保留任何应该永久保存的信息，以防用户坚持离开应用。如果用户从暂停状态返回到您的 Activity ，系统会重新开始该Activity并调用 <code>onResume()</code> 方法。</p><h4 id="暂停Activity"><a href="#暂停Activity" class="headerlink" title="暂停Activity"></a>暂停Activity</h4><p>当系统为 Activity 调用 <code>onPause()</code> 时，它从技术角度看意味着 Activity 仍然处于部分可见状态，但往往说明用户即将离开Activity并且它很快就要进入“停止”状态。 您通常应使用 <code>onPause()</code> 回调：</p><ul><li><p>停止动画或其他可能消耗 CPU 的进行之中的操作。</p></li><li><p>提交未保存的更改，但仅当用户离开时希望永久性保存此类更改（比如电子邮件草稿）。</p></li><li><p>释放系统资源，比如广播接收器、传感器手柄（比如 GPS） 或当您的Activity暂停且用户不需要它们时仍然可能影响电池寿命的任何其他资源。</p></li></ul><p>避免在 <code>onPause()</code> 期间执行 CPU 密集型工作，比如向数据库写入信息，因为这会拖慢向下一 Activity 过渡的过程（应改为在 <code>onStop()</code> 期间执行高负载操作。</p><h4 id="继续Activity"><a href="#继续Activity" class="headerlink" title="继续Activity"></a>继续Activity</h4><p>当用户从“暂停”状态继续您的Activity时，系统会调用 <code>onResume()</code> 方法。</p><p>请注意，每当 Activity 进入前台时系统便会调用此方法，包括它初次创建之时。 同样地，应实现 <code>onResume()</code> 初始化在 <code>onPause()</code> 期间释放的组件并且执行每当 Activity 进入“继续”状态时必须进行的任何其他初始化操作（比如开始动画和初始化只在 Activity 具有用户焦点时使用的组件）。</p><h3 id="停止并重新开始"><a href="#停止并重新开始" class="headerlink" title="停止并重新开始"></a>停止并重新开始</h3><p>几种 Activity 停止和重新开始的关键场景：</p><ul><li><p>用户打开“最近应用”窗口并从您的应用切换到另一个应用。当前位于前台的您的应用中的 Activity 将停止。 如果用户从主屏幕启动器图标或“最近应用”窗口返回到您的应用， Activity 会重新开始。</p></li><li><p>用户在您的应用中执行开始新 Activity 的操作。当第二个 Activity 创建好后，当前 Activity 便停止。如果用户之后按了返回按钮，第一个 Activity 会重新开始。</p></li><li><p>用户在其手机上使用您的应用的同时接听来电。</p></li></ul><p><strong>不同于识别部分 UI 阻挡的暂停状态，停止状态保证 UI 不再可见，且用户的焦点在另外的Activity（或完全独立的应用）中</strong>。</p><h4 id="停止Activity"><a href="#停止Activity" class="headerlink" title="停止Activity"></a>停止Activity</h4><p>当您的Activity收到 <code>onStop()</code> 方法的调用时，它不再可见，并且应释放几乎所有用户不使用时不需要的资源。 一旦您的 Activity 停止，如果需要恢复系统内存，系统可能会销毁该实例。 <strong>在极端情况下，系统可能会仅终止应用进程，而不会调用Activity的最终 <code>onDestroy()</code> 回调，因此您使用 <code>onStop()</code> 释放可能泄露内存的资源非常重要</strong>。</p><p>尽管 <code>onPause()</code> 方法在 <code>onStop()</code>之前调用，您应使用 <code>onStop()</code> 执行更大、占用更多 CPU 的关闭操作，比如向数据库写入信息。</p><p>当您的Activity停止时， Activity 对象将驻留在内存中并在 Activity 继续时被再次调用。 您无需重新初始化在任何导致进入“继续”状态的回调方法过程中创建的组件。 系统还会在布局中跟踪每个 View 的当前状态，如果用户在 EditText 小工具中输入文本，该内容会保留，因此您无需保存即可恢复它。</p><blockquote><p>即使系统在 Activity 停止时销毁了 Activity ，它仍会保留 Bundle（键值对的二进制大对象）中的 View 对象（比如 EditText 中的文本），并在用户导航回 Activity 的相同实例时恢复它们</p></blockquote><h4 id="开始-重新开始Activity"><a href="#开始-重新开始Activity" class="headerlink" title="开始/重新开始Activity"></a>开始/重新开始Activity</h4><p>当您的Activity从停止状态返回前台时，它会接收对 <code>onRestart()</code> 的调用。系统还会在每次您的Activity变为可见时调用 <code>onStart()</code> 方法（无论是正重新开始还是初次创建）。 但是，只会在Activity从停止状态继续时调用 <code>onRestart()</code> 方法，因此您可以使用它执行只有在Activity之前停止但未销毁的情况下可能必须执行的特殊恢复工作。<strong>您应经常使用 onStart() 回调方法作为 onStop() 方法的对应部分，因为系统会在它创建您的Activity以及从停止状态重新开始Activity时调用<code>onStart()</code></strong>。</p><h3 id="重新创建"><a href="#重新创建" class="headerlink" title="重新创建"></a>重新创建</h3><p>在有些情况下，您的 Activity 会因正常应用行为而销毁，比如当用户按 <em>返回按钮</em> 或您的 Activity 通过调用<code>finish()</code>示意自己的销毁。 如果 Activity 当前被停止或长期未使用，或者前台Activity需要更多资源以致系统必须关闭后台进程恢复内存，系统也可能会销毁Activity。</p><p>当您的Activity因用户按了 <em>返回</em>  或Activity自行完成而被销毁时，系统的 Activity 实例概念将永久消失。 但是，如果系统因系统局限性（而非正常应用行为）而销毁Activity，尽管 Activity 实际实例已不在，系统会记住其存在，这样，如果用户导航回实例，系统会使用描述 Activity 被销毁时状态的一组已保存数据创建 Activity 的新实例。 系统用于恢复先前状态的已保存数据被称为“实例状态”，并且是 <code>Bundle</code> 对象中存储的键值对集合。</p><p>默认情况下，系统会使用 <code>Bundle</code> 实例状态保存您的 Activity 布局（比如，输入到 <code>EditText</code> 对象中的文本值）中有关每个 View 对象的信息。 这样，如果您的Activity实例被销毁并重新创建，布局状态便恢复为其先前的状态，且您无需代码。 但是，您的Activity可能具有您要恢复的更多状态信息，比如跟踪用户在 Activity 中进度的成员变量。</p><blockquote><p>为了 Android 系统恢复Activity中视图的状态，每个视图必须具有 android:id 属性提供的唯一 ID。</p></blockquote><p>要保存有关 Activity 状态的其他数据，您必须替代 <code>onSaveInstanceState()</code> 回调方法。当用户要离开 Activity 并在 Activity 意外销毁时向其传递将保存的 Bundle 对象时，系统会调用此方法。 如果系统必须稍后重新创建Activity实例，它会将相同的 Bundle 对象同时传递给 <code>onRestoreInstanceState()</code> 和 <code>onCreate()</code> 方法。</p><p><img src="images/basic-lifecycle-savestate.png" alt=""></p><h4 id="保存Activity状态"><a href="#保存Activity状态" class="headerlink" title="保存Activity状态"></a>保存Activity状态</h4><p>当您的Activity开始停止时，系统会调用 <code>onSaveInstanceState()</code> 以便您的Activity可以保存带有键值对集合的状态信息。 此方法的默认实现保存有关Activity视图层次的状态信息（只保存部分 View ），例如 EditText 小工具中的文本或ListView 的滚动位置。要保存Activity的更多状态信息，您必须实现 <code>onSaveInstanceState()</code> 并将键值对添加至 Bundle 对象。</p><p>如果当系统配置改变时，不希望重建Activity，可以给Activity指定<code>configChanges</code>属性。当被配置的系统配置发生改变时会调用<code>onConfigurationChanged()</code>方法，而不会调用<code>onSaveInstanceState()</code>。</p><blockquote><p>onSaveInstanceState() 的调用时机是不明确的，但是如果调用就一定会在 onStop()之前。</p></blockquote><h4 id="恢复Activity状态"><a href="#恢复Activity状态" class="headerlink" title="恢复Activity状态"></a>恢复Activity状态</h4><p>当您的Activity在先前销毁之后重新创建时，您可以从系统向Activity传递的 Bundle 恢复已保存的状态。<code>onCreate()</code> 和 <code>onRestoreInstanceState()</code> 回调方法均接收包含实例状态信息的相同 Bundle。</p><p>因为无论系统正在创建Activity的新实例还是重新创建先前的实例，都会调用 <code>onCreate()</code> 方法，因此您必须在尝试读取它之前检查状态 Bundle 是否为 null。 如果为 null，则系统将创建Activity的新实例，而不是恢复已销毁的先前实例。</p><h2 id="Service生命周期"><a href="#Service生命周期" class="headerlink" title="Service生命周期"></a>Service生命周期</h2><ul><li><p>Start Service：通过<code>context.startService()</code>启动，这种service可以无限制的运行，除非调用<code>stopSelf()</code>或者其他组件调用<code>context.stopService()</code>。</p></li><li><p>Bind Service：通过<code>context.bindService()</code>启动，客户可以通过IBinder接口和service通信，客户可以通过<code>context.unBindService()</code>取消绑定。一个service可以和多个客户绑定，当所有客户都解除绑定后，service将终止运行。</p><blockquote><p>一个通过<code>context.startService()</code>方法启动的service，其他组件也可以通过<code>context.bindService()</code>与它绑定，在这种情况下，不能使用<code>stopSelf()</code>或者<code>context.stopService()</code>停止service，只能当所有客户解除绑定在调用<code>context.stopService()</code>才会终止。</p></blockquote></li></ul><p><img src="images/service_life.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Activity生命周期&quot;&gt;&lt;a href=&quot;#Activity生命周期&quot; class=&quot;headerlink&quot; title=&quot;Activity生命周期&quot;&gt;&lt;/a&gt;Activity生命周期&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;images/activity-basic-lifecycle.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上面的图中存在不同状态之间的过渡，但是，这些状态中只有三种可以是静态，也就是说 Activity 只能在三种状态之一下存在很长时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;继续&lt;/strong&gt;：在这种状态下，Activity处于前台，且用户可以与其交互（又称为运行态，在调用 &lt;code&gt;onResume()&lt;/code&gt; 方法调用后）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;暂停&lt;/strong&gt;：在这种状态下，Activity被在前台中处于半透明状态或者未覆盖整个屏幕的另一个Activity—部分阻挡。 暂停的Activity不会接收用户输入并且无法执行任何代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;停止&lt;/strong&gt;：在这种状态下，Activity被完全隐藏并且对用户不可见；它被视为处于后台。 停止时，Activity实例及其诸如成员变量等所有状态信息将保留，但它无法执行任何代码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他状态（“创建”和“开始”）是瞬态，系统会通过调用下一个生命周期回调方法从这些状态快速移到下一个状态。 也就是说，在系统调用 &lt;code&gt;onCreate()&lt;/code&gt; 之后，它会快速调用 &lt;code&gt;onStart()&lt;/code&gt;，紧接着快速调用 &lt;code&gt;onResume()&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;创建和销毁&quot;&gt;&lt;a href=&quot;#创建和销毁&quot; class=&quot;headerlink&quot; title=&quot;创建和销毁&quot;&gt;&lt;/a&gt;创建和销毁&lt;/h3&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="Activity" scheme="http://www.yangxiaozong.com/tags/Activity/"/>
    
      <category term="Service" scheme="http://www.yangxiaozong.com/tags/Service/"/>
    
  </entry>
  
  <entry>
    <title>Intent</title>
    <link href="http://www.yangxiaozong.com/Intent.html"/>
    <id>http://www.yangxiaozong.com/Intent.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.224Z</updated>
    
    <content type="html"><![CDATA[<p>Intent 是一个消息传递对象，您可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p><ul><li><p>启动Activity：<code>startActivity()</code></p></li><li><p>启动服务：<code>bindService()</code></p></li><li><p>传递广播：<code>sendBroadcast()</code></p></li></ul><h2 id="Intent-类型"><a href="#Intent-类型" class="headerlink" title="Intent 类型"></a>Intent 类型</h2><a id="more"></a><p>Intent 分为两种类型：</p><ul><li><p><strong>显式 Intent</strong>：<strong>按名称（完全限定类名）指定要启动的组件</strong>。</p></li><li><p><strong>隐式 Intent</strong>：<strong>不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理它</strong>。</p></li></ul><p>创建<code>显式 Intent</code> 启动 Activity 或服务时，系统将立即启动 Intent 对象中指定的应用组件。</p><p><img src="images/intent-filters.png" alt=""></p><blockquote><p>隐式 Intent 如何通过系统传递以启动其他 Activity 的图解</p></blockquote><p>创建<code>隐式 Intent</code> 时，Android 系统通过将 Intent 的内容与在设备上其他应用的清单文件中声明的 Intent 过滤器进行比较，从而找到要启动的相应组件。Intent如果 Intent 与 Intent 过滤器匹配，则系统将启动该组件，并将其传递给对象。如果多个 Intent 过滤器兼容，则系统会显示一个对话框，支持用户选取要使用的应用。</p><blockquote><p>为了确保应用的安全性，启动 Service 时，请始终使用显式 Intent，且不要为服务声明 Intent 过滤器。从 Android 5.0（API 级别 21）开始，如果使用隐式 Intent 调用 bindService()，系统会抛出异常。</p></blockquote><h2 id="构建-Intent"><a href="#构建-Intent" class="headerlink" title="构建 Intent"></a>构建 Intent</h2><ul><li><p><strong>组件名称(ComponentName)</strong>：这是可选项，但也是构建显式 Intent 的一项重要信息，这意味着 Intent 应当仅传递给由组件名称定义的应用组件。Intent 的这一字段是 <code>ComponentName</code> 对象，您可以使用目标组件的完全限定类名指定此对象，其中包括应用的软件包名称。</p></li><li><p><strong>操作(Action)</strong>：指定要执行的通用操作（例如，“查看”或“选取”）的字符串。</p></li><li><p><strong>数据(Data)</strong>：引用待操作数据和/或该数据 MIME 类型的 URI（Uri 对象）。提供的数据类型通常由 Intent 的操作决定。</p><blockquote><p>要仅设置数据 URI，请调用 setData()。要仅设置 MIME 类型，请调用 setType()。如有必要，您可以使用 setDataAndType() 同时显式设置二者。</p><p>警告：若要同时设置 URI 和 MIME 类型，请勿调用 setData() 和 setType()，因为它们会互相抵消彼此的值。请始终使用 setDataAndType() 同时设置 URI 和 MIME 类型。</p></blockquote></li><li><p><strong>类别(Category)</strong>：一个包含应处理 Intent 组件类型的附加信息的字符串。您可以将任意数量的类别描述放入一个 Intent 中，但大多数 Intent 均不需要类别。</p></li><li><p><strong>Extra</strong>：携带完成请求操作所需的附加信息的键值对。正如某些操作使用特定类型的数据 URI 一样，有些操作也使用特定的附加数据。例如，使用 <code>ACTION_SEND</code> 创建用于发送电子邮件的 Intent 时，可以使用 <code>EXTRA_EMAIL</code> 键指定“目标”收件人，并使用 <code>EXTRA_SUBJECT</code> 键指定“主题”。</p></li><li><p><strong>标志(Flags)</strong>：在 Intent 类中定义的、充当 Intent 元数据的标志。标志可以指示 Android 系统如何启动 Activity（例如，Activity 应属于哪个Task ）。</p></li></ul><h2 id="Intent-解析"><a href="#Intent-解析" class="headerlink" title="Intent 解析"></a>Intent 解析</h2><p>当系统收到隐式 Intent 以启动 Activity 时，它根据以下三个方面将该 Intent 与 Intent 过滤器进行比较，搜索该 Intent 的最佳 Activity：</p><ul><li><p>Intent 操作</p></li><li><p>Intent 数据（URI 和数据类型）</p></li><li><p>Intent 类别</p></li></ul><p>系统通过将 Intent 与所有这三个元素进行比较，根据过滤器测试隐式 Intent。<strong>隐式 Intent 若要传递给组件，必须通过所有这三项测试。如果 Intent 甚至无法匹配其中任何一项测试，则 Android 系统不会将其传递给组件</strong>。但是，由于一个组件可能有多个 Intent 过滤器，因此未能通过某一组件过滤器的 Intent 可能会通过另一过滤器。（在Demo中实验了几次，发现 Action 和 Data 必须至少设置一个，否则不能匹配到）</p><h3 id="操作（Action）匹配"><a href="#操作（Action）匹配" class="headerlink" title="操作（Action）匹配"></a>操作（Action）匹配</h3><p>要指定接受的 Intent 操作， Intent 过滤器既可以不声明任何 <code>action</code> 元素，也可以声明多个此类元素。例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.EDIT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要通过此过滤器，您在 Intent 中指定的操作必须与过滤器中列出的 <strong>某一操作匹配</strong>。</p><p>如果该过滤器未列出任何操作，则 Intent 没有任何匹配项，因此所有 Intent 均无法通过测试。但是，如果 Intent 未指定操作，则会通过测试（只要过滤器至少包含一个操作）。</p><h3 id="类别（Category）匹配"><a href="#类别（Category）匹配" class="headerlink" title="类别（Category）匹配"></a>类别（Category）匹配</h3><p>要指定接受的 Intent 类别， Intent 过滤器既可以不声明任何 <code>category</code> 元素，也可以声明多个此类元素。例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若要 Intent 通过类别测试，则 <strong>Intent 中的每个类别均必须与过滤器中的类别匹配</strong>。反之则未必然，<strong>Intent 过滤器声明的类别可以超出 Intent 中指定的数量，且 Intent 仍会通过测试。因此，不含类别的 Intent 应当始终会通过此测试，无论过滤器中声明何种类别均是如此</strong>。</p><blockquote><p>Android 会自动将 <code>CATEGORY_DEFAULT</code> 类别应用于传递给 <code>startActivity()</code> 和 <code>startActivityForResult()</code> 的所有隐式 Intent。因此，如需 Activity 接收隐式 Intent，则必须将 “<code>android.intent.category.DEFAULT</code>“ 的类别包括在其 Intent 过滤器中。</p></blockquote><h3 id="数据（Data）匹配"><a href="#数据（Data）匹配" class="headerlink" title="数据（Data）匹配"></a>数据（Data）匹配</h3><p>要指定接受的 Intent 数据， Intent 过滤器既可以不声明任何 <code>data</code> 元素，也可以声明多个此类元素。例如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"video/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"audio/mpeg"</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个 <code>&lt;data&gt;</code> 元素均可指定 URI 结构和数据类型（MIME 介质类型）。URI 的每个部分均包含单独的 scheme、host、port 和 path 属性：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scheme://host:port/path</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">content://com.example.project:200/folder/subfolder/etc</span><br></pre></td></tr></table></figure><p>在此 URI 中，架构是 <code>content</code>，主机是 <code>com.example.project</code>，端口是 <code>200</code>，路径是 <code>folder/subfolder/etc</code>。上述每个属性均为可选，但存在线性依赖关系：</p><ul><li><p>如果未指定架构，则会忽略主机。</p></li><li><p>如果未指定主机，则会忽略端口。</p></li><li><p>如果未指定架构和主机，则会忽略路径。</p></li></ul><p>将 Intent 中的 URI 与过滤器中的 URI 规范进行比较时，它仅与过滤器中包含的部分 URI 进行比较。例如：</p><ul><li><p>如果过滤器仅指定架构，则具有该架构的所有 URI 均与该过滤器匹配。</p></li><li><p>如果过滤器指定架构和权限、但未指定路径，则具有相同架构和权限的所有 URI 都会通过过滤器，无论其路径如何均是如此。</p></li><li><p>如果过滤器指定架构、权限和路径，则仅具有相同架构、权限和路径 的 URI 才会通过过滤器。</p></li></ul><blockquote><p>路径规范可以包含星号通配符 ( * )，因此仅需部分匹配路径名即可。</p></blockquote><p>数据匹配会将 Intent 中的 URI 和 MIME 类型与过滤器中指定的 URI 和 MIME 类型进行比较。规则如下：</p><ul><li><p>仅当过滤器未指定任何 URI 或 MIME 类型时，不含 URI 和 MIME 类型的 Intent 才会通过测试。</p></li><li><p>对于包含 URI、但不含 MIME 类型（既未显式声明，也无法通过 URI 推断得出）的 Intent，仅当其 URI 与过滤器的 URI 格式匹配、且过滤器同样未指定 MIME 类型时，才会通过测试。</p></li><li><p>仅当过滤器列出相同的 MIME 类型且未指定 URI 格式时，包含 MIME 类型、但不含 URI 的 Intent 才会通过测试。</p></li><li><p>仅当 MIME 类型与过滤器中列出的类型匹配时，包含 URI 和 MIME 类型（通过显式声明，或可以通过 URI 推断得出）的 Intent 才会通过测试的 MIME 类型部分。如果 Intent 的 URI 与过滤器中的 URI 匹配，或者如果 Intent 具有 <code>content:</code> 或 <code>file:</code> URI 且过滤器未指定 URI，则 Intent 会通过测试的 URI 部分。换而言之，如果过滤器仅列出 MIME 类型，则假定组件支持 <code>content:</code> 和 <code>file:</code> 数据。</p></li></ul><p>最后一条规则，反映了期望组件能够从文件中或 <code>内容提供者</code> 处获得本地数据。因此，其过滤器可以仅列出数据类型，而不必显式命名 <code>content:</code> 和 <code>file:</code> 架构。这是一个典型的案例。例如，下文中的 <code>data</code> 元素向 Android 指出，组件可从 <code>内容提供者</code> 处获得并显示图像数据。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"image/*"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Intent-匹配"><a href="#Intent-匹配" class="headerlink" title="Intent 匹配"></a>Intent 匹配</h2><p>您的应用可以采用类似的方式使用 Intent 匹配。<code>PackageManager</code> 提供了一整套 <code>query...()</code> 方法来返回所有能够接受特定 Intent 的组件。此外，它还提供了一系列类似的 <code>resolve...()</code> 方法来确定响应 Intent 的最佳组件。例如，<code>queryIntentActivities()</code>将返回能够执行那些作为参数传递的 Intent 的所有 Activity 列表，而 <code>queryIntentServices()</code> 则可返回类似的服务列表。这两种方法均不会激活组件，而只是列出能够响应的组件。对于广播接收器，有一种类似的方法： <code>queryBroadcastReceivers()</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Intent 是一个消息传递对象，您可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;启动Activity：&lt;code&gt;startActivity()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动服务：&lt;code&gt;bindService()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;传递广播：&lt;code&gt;sendBroadcast()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Intent-类型&quot;&gt;&lt;a href=&quot;#Intent-类型&quot; class=&quot;headerlink&quot; title=&quot;Intent 类型&quot;&gt;&lt;/a&gt;Intent 类型&lt;/h2&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="Intent" scheme="http://www.yangxiaozong.com/tags/Intent/"/>
    
  </entry>
  
  <entry>
    <title>版本问题</title>
    <link href="http://www.yangxiaozong.com/%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98.html"/>
    <id>http://www.yangxiaozong.com/版本问题.html</id>
    <published>2019-09-14T01:40:28.000Z</published>
    <updated>2019-09-17T12:32:31.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CompileSdkVersion"><a href="#CompileSdkVersion" class="headerlink" title="CompileSdkVersion"></a>CompileSdkVersion</h2><p><code>compileSdkVersion</code> 告诉 Gradle 用哪个 Android SDK 版本编译你的应用。使用任何新添加的 API 就需要使用对应 Level 的 Android SDK。</p><p>需要强调的是修改 <code>compileSdkVersion</code> 不会改变运行时的行为。当你修改了 <code>compileSdkVersion</code> 的时候，可能会出现新的编译警告、编译错误，但新的 <code>compileSdkVersion</code> 不会被包含到 APK 中：它纯粹只是在编译的时候使用。（你真的应该修复这些警告，他们的出现一定是有原因的）</p><p>因此我们强烈推荐总是使用最新的 SDK 进行编译。在现有代码上使用新的编译检查可以获得很多好处，避免新弃用的 API ，并且为使用新的 API 做好准备。</p><p>注意，如果使用 <code>Support Library</code> ，那么使用最新发布的 <code>Support Library</code> 就需要使用最新的 SDK 编译。例如，要使用 23.1.1 版本的 <code>Support Library</code> ，<code>compileSdkVersion</code> 就必需至少是 23 （大版本号要一致！）。通常，新版的 <code>Support Library</code> 随着新的系统版本而发布，它为系统新增加的 API 和新特性提供兼容性支持。</p><h2 id="MinSdkVersion"><a href="#MinSdkVersion" class="headerlink" title="MinSdkVersion"></a>MinSdkVersion</h2><a id="more"></a><p>如果 <code>compileSdkVersion</code> 设置为可用的最新 API，那么 <code>minSdkVersion</code> 则是应用可以运行的最低要求。<code>minSdkVersion</code> 是 Google Play 商店用来判断用户设备是否可以安装某个应用的标志之一。</p><p>在开发时 <code>minSdkVersion</code> 也起到一个重要角色：<code>lint</code> 默认会在项目中运行，它在你使用了高于 <code>minSdkVersion</code>  的 API 时会警告你，帮你避免调用不存在的 API 的运行时问题。如果只在较高版本的系统上才使用某些 API，通常使用运行时检查系统版本的方式解决。</p><p>请记住，你所使用的库，如 <code>Support Library</code> 或 <code>Google Play services</code>，可能有他们自己的 <code>minSdkVersio</code>n 。你的应用设置的 <code>minSdkVersion</code> 必需大于等于这些库的 <code>minSdkVersion</code> 。</p><p>当你决定使用什么 <code>minSdkVersion</code> 时候，你应该参考当前的 Android 分布统计，它显示了最近 7 天所有访问 Google Play 的设备信息。他们就是你把应用发布到 Google Play 时的潜在用户。最终这是一个商业决策问题，取决于为了支持额外 3% 的设备，确保最佳体验而付出的开发和测试成本是否值得。</p><p>当然，如果某个新的 API 是你整个应用的关键，那么确定 <code>minSdkVersion</code> 的值就比较容易了。不过要记得 14 亿设备中的 0.7％ 也是个不小的数字。</p><h2 id="TargetSdkVersion"><a href="#TargetSdkVersion" class="headerlink" title="TargetSdkVersion"></a>TargetSdkVersion</h2><p>三个版本号中最有趣的就是 <code>targetSdkVersion</code> 了。 <code>targetSdkVersion</code> 是 Android 提供向前兼容的主要依据，在应用的 <code>targetSdkVersion</code> 没有更新之前系统不会应用最新的行为变化。这允许你在适应新的行为变化之前就可以使用新的 API （因为你已经更新了 <code>compileSdkVersion</code> 不是吗？）。</p><p><code>targetSdkVersion</code> 所暗示的许多行为变化都记录在 VERSION_CODES 文档中了，但是所有恐怖的细节也都列在每次发布的平台亮点中了，在这个 API Level 表中可以方便地找到相应的链接。</p><p>例如，Android 6.0 变化文档中谈了 target 为 API 23 时会如何把你的应用转换到运行时权限模型上，Android 4.4 行为变化阐述了 target 为 API 19 及以上时使用 <code>set()</code> 和 <code>setRepeating()</code> 设置 alarm 会有怎样的行为变化。</p><p>由于某些行为的变化对用户是非常明显的（弃用的 menu 按钮，运行时权限等），所以将 target 更新为最新的 SDK 是所有应用都应该优先处理的事情。但这不意味着你一定要使用所有新引入的功能，也不意味着你可以不做任何测试就盲目地更新 <code>targetSdkVersion</code> ，请一定在更新 <code>targetSdkVersion</code> 之前做测试！你的用户会感谢你的。</p><h2 id="综合来看"><a href="#综合来看" class="headerlink" title="综合来看"></a>综合来看</h2><p>如果你按照上面示例那样配置，你会发现这三个值的关系是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">minSdkVersion &lt;= targetSdkVersion &lt;= compileSdkVersion</span><br></pre></td></tr></table></figure><p>这种直觉是合理的，如果 <code>compileSdkVersion</code> 是你的最大值，<code>minSdkVersion</code> 是最小值，那么最大值必需至少和最小值一样大且 target 必需在二者之间。</p><p>理想上，在稳定状态下三者的关系应该更像这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">minSdkVersion (lowest possible) &lt;=</span><br><span class="line">    targetSdkVersion == compileSdkVersion (latest SDK)</span><br></pre></td></tr></table></figure><p>用较低的 <code>minSdkVersion</code> 来覆盖最大的人群，用最新的 SDK 设置 target 和 compile 来获得最好的外观和行为。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CompileSdkVersion&quot;&gt;&lt;a href=&quot;#CompileSdkVersion&quot; class=&quot;headerlink&quot; title=&quot;CompileSdkVersion&quot;&gt;&lt;/a&gt;CompileSdkVersion&lt;/h2&gt;&lt;p&gt;&lt;code&gt;compileSdkVersion&lt;/code&gt; 告诉 Gradle 用哪个 Android SDK 版本编译你的应用。使用任何新添加的 API 就需要使用对应 Level 的 Android SDK。&lt;/p&gt;
&lt;p&gt;需要强调的是修改 &lt;code&gt;compileSdkVersion&lt;/code&gt; 不会改变运行时的行为。当你修改了 &lt;code&gt;compileSdkVersion&lt;/code&gt; 的时候，可能会出现新的编译警告、编译错误，但新的 &lt;code&gt;compileSdkVersion&lt;/code&gt; 不会被包含到 APK 中：它纯粹只是在编译的时候使用。（你真的应该修复这些警告，他们的出现一定是有原因的）&lt;/p&gt;
&lt;p&gt;因此我们强烈推荐总是使用最新的 SDK 进行编译。在现有代码上使用新的编译检查可以获得很多好处，避免新弃用的 API ，并且为使用新的 API 做好准备。&lt;/p&gt;
&lt;p&gt;注意，如果使用 &lt;code&gt;Support Library&lt;/code&gt; ，那么使用最新发布的 &lt;code&gt;Support Library&lt;/code&gt; 就需要使用最新的 SDK 编译。例如，要使用 23.1.1 版本的 &lt;code&gt;Support Library&lt;/code&gt; ，&lt;code&gt;compileSdkVersion&lt;/code&gt; 就必需至少是 23 （大版本号要一致！）。通常，新版的 &lt;code&gt;Support Library&lt;/code&gt; 随着新的系统版本而发布，它为系统新增加的 API 和新特性提供兼容性支持。&lt;/p&gt;
&lt;h2 id=&quot;MinSdkVersion&quot;&gt;&lt;a href=&quot;#MinSdkVersion&quot; class=&quot;headerlink&quot; title=&quot;MinSdkVersion&quot;&gt;&lt;/a&gt;MinSdkVersion&lt;/h2&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.yangxiaozong.com/categories/Android/"/>
    
    
      <category term="面试题" scheme="http://www.yangxiaozong.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题-java基础篇(一)</title>
    <link href="http://www.yangxiaozong.com/Java%E9%9D%A2%E8%AF%95%E9%A2%98-java%E5%9F%BA%E7%A1%80%E7%AF%87.html"/>
    <id>http://www.yangxiaozong.com/Java面试题-java基础篇.html</id>
    <published>2019-08-09T11:40:28.000Z</published>
    <updated>2019-09-17T12:29:01.211Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Java-面向对象"><a href="#一、Java-面向对象" class="headerlink" title="一、Java 面向对象"></a>一、Java 面向对象</h3><h4 id="1-面向对象都有哪些特性以及你对这些特性的理解"><a href="#1-面向对象都有哪些特性以及你对这些特性的理解" class="headerlink" title="1.面向对象都有哪些特性以及你对这些特性的理解"></a>1.面向对象都有哪些特性以及你对这些特性的理解</h4><p>1) 继承:继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类(超类、基类);得到继 承信息的类被称为子类(派生类)。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的 重要手段。<br>2) 封装:通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象 的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装;我 们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程 接口。<br>3) 多态性:多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调 用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外 界提供的服务，那么运行时的多态性可以解释为:当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式， 但一切对 A 系统来说都是透明的。方法重载(overload)实现的是编译时的多态性(也称为前绑定)，而方法重写 (override)实现的是运行时的多态性(也称为后绑定)。运行时的多态是面向对象最精髓的东西，要实现多态需要做 两件事:1. 方法重写(子类继承父类并重写父类中已有的或抽象的方法);2. 对象造型(用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为)。<br>4) 抽象:抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对 象有哪些属性和行为，并不关注这些行为的细节是什么。<br><a id="more"></a><br>注意:默认情况下面向对象有 3 大特性，封装、继承、多态，如果面试官问让说出 4 大特性，那么我们就把抽象 加上去。</p><h4 id="2-访问权限修饰符-public、private、protected-以及不写-默认-时的区别"><a href="#2-访问权限修饰符-public、private、protected-以及不写-默认-时的区别" class="headerlink" title="2.访问权限修饰符 public、private、protected, 以及不写(默认)时的区别"></a>2.访问权限修饰符 public、private、protected, 以及不写(默认)时的区别</h4><p>该题目比较简单，不同的权限修饰符的区别见下表。</p><table><thead><tr><th>修饰符</th><th>当前类</th><th>同包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>✓</td><td>✓</td><td>✓</td><td>✓</td><td></td></tr><tr><td>protected</td><td>✓</td><td>✓</td><td>✓</td><td>✗</td><td></td></tr><tr><td>default</td><td>✓</td><td>✓</td><td>✗</td><td>✗</td><td></td></tr><tr><td>private</td><td>✓</td><td>✗</td><td>✗</td><td>✗</td><td></td></tr></tbody></table><h4 id="3-如何理解-clone-对象"><a href="#3-如何理解-clone-对象" class="headerlink" title="3. 如何理解 clone 对象"></a>3. 如何理解 clone 对象</h4><h5 id="3-1-为什么要用-clone"><a href="#3-1-为什么要用-clone" class="headerlink" title="3.1 为什么要用 clone?"></a>3.1 为什么要用 clone?</h5><p>在实际编程过程中，我们常常要遇到这种情况:有一个对象 A，在某一时刻 A 中已经包含了一些有效值，此时可 能会需要一个和 A 完全相同新对象 B，并且此后对 B 任何改动都不会影响到 A 中的值，也就是说，A 与 B 是两个独立 的对象，但 B 的初始值是由 A 对象确定的。在 Java 语言中，用简单的赋值语句是不能满足这种需求的。要满足这种需 求虽然有很多途径，但实现 clone()方法是其中最简单，也是最高效的手段。</p><h5 id="3-2-new-一个对象的过程和-clone-一个对象的过程区别"><a href="#3-2-new-一个对象的过程和-clone-一个对象的过程区别" class="headerlink" title="3.2 new 一个对象的过程和 clone 一个对象的过程区别"></a>3.2 new 一个对象的过程和 clone 一个对象的过程区别</h5><p>new 操作符的本意是分配内存。程序执行到 new 操作符时，首先去看 new 操作符后面的类型，因为知道了类型，<br>才能知道要分配多大的内存空间。分配完内存之后，再调用构造函数，填充对象的各个域，这一步叫做对象的初始化，构造方法返回后，一个对象创建完毕，可以把他的引用(地址)发布到外部，在外部就可以使用这个引用操纵这个对<br>象。</p><p>clone 在第一步是和 new 相似的，都是分配内存，调用 clone 方法时，分配的内存和原对象(即调用 clone 方法 的对象)相同，然后再使用原对象中对应的各个域，填充新对象的域，填充完成之后，clone 方法返回，一个新的相同 的对象被创建，同样可以把这个新对象的引用发布到外部。</p><h5 id="3-3-clone-对象的使用"><a href="#3-3-clone-对象的使用" class="headerlink" title="3.3 clone 对象的使用"></a>3.3 clone 对象的使用</h5><h6 id="3-3-1-复制对象和复制引用的区别"><a href="#3-3-1-复制对象和复制引用的区别" class="headerlink" title="3.3.1 复制对象和复制引用的区别"></a>3.3.1 复制对象和复制引用的区别</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">"zhang"</span>);</span><br><span class="line">Person p1 = p;</span><br><span class="line">System.out.println(p);</span><br><span class="line">System.out.println(p1);</span><br></pre></td></tr></table></figure><p>当 Person p1 = p;执行之后， 是创建了一个新的对象吗? 首先看打印结果:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.itheima.Person@<span class="number">2f</span>9ee1ac</span><br><span class="line">com.itheima.Person@<span class="number">2f</span>9ee1ac</span><br></pre></td></tr></table></figure><p>可以看出，打印的地址值是相同的，既然地址都是相同的，那么肯定是同一个对象。p 和 p1 只是引用而已，他们 都指向了一个相同的对象 Person(23, “zhang”) 。 可以把这种现象叫做引用的复制。上面代码执行完成之后， 内 存中的情景如下图所示:<br><img src="http://blog.yangxiaozong.com/images/156533217207261D5DAD8599DC874AFFD4EE2D3E03B6E.jpg" alt="image"><br>而下面的代码是真真正正的克隆了一个对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">"zhang"</span>);</span><br><span class="line">Person p1 = (Person) p.clone();</span><br><span class="line">System.out.println(p);</span><br><span class="line">System.out.println(p1);</span><br></pre></td></tr></table></figure></p><p>从打印结果可以看出，两个对象的地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个 新的引用变量:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.itheima.Person@<span class="number">2f</span>9ee1ac</span><br><span class="line">com.itheima.Person@<span class="number">67f</span>1fba0</span><br></pre></td></tr></table></figure></p><p>以上代码执行完成后， 内存中的情景如下图所示:<br><img src="http://blog.yangxiaozong.com/images/1565332485022986F25580A074152313E67F7D439A52B.jpg" alt="image"></p><h6 id="3-3-2-深拷贝和浅拷贝"><a href="#3-3-2-深拷贝和浅拷贝" class="headerlink" title="3.3.2 深拷贝和浅拷贝"></a>3.3.2 深拷贝和浅拷贝</h6><p>上面的示例代码中，Person 中有两个成员变量，分别是 name 和 age， name 是 String 类型， age 是 int 类 型。代码非常简单，如下所示:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"><span class="title">private</span> <span class="title">int</span> <span class="title">age</span> </span>;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age=age;</span><br><span class="line"><span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Person)<span class="keyword">super</span>.clone();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于 age 是基本数据类型，那么对它的拷贝没有什么疑议，直接将一个 4 字节的整数值拷贝过来就行。但是 name 是 String 类型的， 它只是一个引用， 指向一个真正的 String 对象，那么对它的拷贝有两种方式: 直接将原对象中 的 name 的引用值拷贝给新对象的 name 字段， 或者是根据原 Person 对象中的 name 指向的字符串对象创建一个 新的相同的字符串对象，将这个新字符串对象的引用赋给新拷贝的 Person 对象的 name 字段。这两种拷贝方式分别 叫做浅拷贝和深拷贝。深拷贝和浅拷贝的原理如下图所示:<br><img src="http://blog.yangxiaozong.com/images/1565333797118209F3561C5C63089D1AE84CA9D841F13.jpg" alt="image"></p><p>下面通过代码进行验证。如果两个 Person 对象的 name 的地址值相同， 说明两个对象的 name 都指向同一个 String 对象，也就是浅拷贝， 而如果两个对象的 name 的地址值不同， 那么就说明指向不同的 String 对象， 也就 是在拷贝 Person 对象的时候， 同时拷贝了 name 引用的 String 对象， 也就是深拷贝。验证代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">"zhang"</span>);</span><br><span class="line">Person p1 = (Person) p.clone();</span><br><span class="line">String result = p.getName() == p1.getName()? <span class="string">"clone 是浅拷贝的"</span> : <span class="string">"clone 是深拷贝的"</span>; </span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure></p><p>打印结果为:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">clone 是浅拷贝的</span><br></pre></td></tr></table></figure></p><p>所以，clone 方法执行的是浅拷贝， 在编写程序时要注意这个细节。<br>如何进行深拷贝:<br>由上一节的内容可以得出如下结论:如果想要深拷贝一个对象，这个对象必须要实现 Cloneable 接口，实现 clone 方法，并且在 clone 方法内部，把该对象引用的其他对象也要 clone 一份，这就要求这个被引用的对象必须也要实现 Cloneable 接口并且实现 clone 方法。那么，按照上面的结论，实现以下代码 Body 类组合了 Head 类，要想深拷贝 Body 类，必须在 Body 类的 clone 方法中将 Head 类也要拷贝一份。代码如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> Head head;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Body</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Body</span><span class="params">(Head head)</span></span>&#123;<span class="keyword">this</span>.head.head=head;&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Body newBody=(Body) <span class="keyword">super</span>.clone();</span><br><span class="line">newBody.head=(Head) head.clone();</span><br><span class="line"><span class="keyword">return</span> newBody;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Head</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"> <span class="keyword">public</span> Face face;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Head</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line"> &#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">Body body = <span class="keyword">new</span> Body(<span class="keyword">new</span> Head(<span class="keyword">new</span> Face()));</span><br><span class="line">Body body1 = (Body) body.clone();</span><br><span class="line"> System.out.println(<span class="string">"body == body1 : "</span> + (body == body1) );</span><br><span class="line">System.out.println(<span class="string">"body.head == body1.head : "</span> + (body.head == body1.head));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>打印结果为:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">body == body1 : <span class="keyword">false</span></span><br><span class="line">body.head == body1.head : <span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、Java-面向对象&quot;&gt;&lt;a href=&quot;#一、Java-面向对象&quot; class=&quot;headerlink&quot; title=&quot;一、Java 面向对象&quot;&gt;&lt;/a&gt;一、Java 面向对象&lt;/h3&gt;&lt;h4 id=&quot;1-面向对象都有哪些特性以及你对这些特性的理解&quot;&gt;&lt;a href=&quot;#1-面向对象都有哪些特性以及你对这些特性的理解&quot; class=&quot;headerlink&quot; title=&quot;1.面向对象都有哪些特性以及你对这些特性的理解&quot;&gt;&lt;/a&gt;1.面向对象都有哪些特性以及你对这些特性的理解&lt;/h4&gt;&lt;p&gt;1) 继承:继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类(超类、基类);得到继 承信息的类被称为子类(派生类)。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的 重要手段。&lt;br&gt;2) 封装:通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。面向对象 的本质就是将现实世界描绘成一系列完全自治、封闭的对象。我们在类中编写的方法就是对实现细节的一种封装;我 们编写一个类就是对数据和数据操作的封装。可以说，封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程 接口。&lt;br&gt;3) 多态性:多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调 用同样的方法但是做了不同的事情。多态性分为编译时的多态性和运行时的多态性。如果将对象的方法视为对象向外 界提供的服务，那么运行时的多态性可以解释为:当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式， 但一切对 A 系统来说都是透明的。方法重载(overload)实现的是编译时的多态性(也称为前绑定)，而方法重写 (override)实现的是运行时的多态性(也称为后绑定)。运行时的多态是面向对象最精髓的东西，要实现多态需要做 两件事:1. 方法重写(子类继承父类并重写父类中已有的或抽象的方法);2. 对象造型(用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为)。&lt;br&gt;4) 抽象:抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对 象有哪些属性和行为，并不关注这些行为的细节是什么。&lt;br&gt;
    
    </summary>
    
      <category term="Java面试题" scheme="http://www.yangxiaozong.com/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java面试题" scheme="http://www.yangxiaozong.com/tags/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud教程第6篇：config</title>
    <link href="http://www.yangxiaozong.com/SpringCloud%E6%95%99%E7%A8%8B%E7%AC%AC6%E7%AF%87%EF%BC%9Aconfig.html"/>
    <id>http://www.yangxiaozong.com/SpringCloud教程第6篇：config.html</id>
    <published>2019-03-08T06:35:33.000Z</published>
    <updated>2019-09-17T12:25:02.956Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章讲述zuul的时候，已经提到过，使用配置服务来保存各个服务的配置文件。它就是Spring Cloud Config。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p><a id="more"></a><h3 id="构建Config-Server"><a href="#构建Config-Server" class="headerlink" title="构建Config Server"></a>构建Config Server</h3><p>创建一个spring-boot项目，取名为config-server,其pom.xml:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.forezp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>config-server<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Camden.SR6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在程序的入口Application类加上@EnableConfigServer注解开启配置服务器的功能，代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要在程序的配置文件application.properties文件配置以下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">spring.application.name=config-server</span></span><br><span class="line"><span class="string">server.port=8888</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">spring.cloud.config.server.git.uri=https://github.com/forezp/SpringcloudConfig/</span></span><br><span class="line"><span class="string">spring.cloud.config.server.git.searchPaths=respo</span></span><br><span class="line"><span class="string">spring.cloud.config.label=master</span></span><br><span class="line"><span class="string">spring.cloud.config.server.git.username=your</span> <span class="string">username</span></span><br><span class="line"><span class="string">spring.cloud.config.server.git.password=your</span> <span class="string">password</span></span><br></pre></td></tr></table></figure><ul><li>spring.cloud.config.server.git.uri：配置git仓库地址</li><li>spring.cloud.config.server.git.searchPaths：配置仓库路径</li><li>spring.cloud.config.label：配置仓库的分支</li><li>spring.cloud.config.server.git.username：访问git仓库的用户名</li><li>spring.cloud.config.server.git.password：访问git仓库的用户密码</li></ul><p>如果Git仓库为公开仓库，可以不填写用户名和密码，如果是私有仓库需要填写，本例子是公开仓库，放心使用。</p><p>远程仓库<a href="https://github.com/forezp/SpringcloudConfig/" target="_blank" rel="noopener">https://github.com/forezp/SpringcloudConfig/</a> 中有个文件config-client-dev.properties文件中有一个属性：</p><p>foo = foo version 3</p><p>启动程序：访问<a href="http://localhost:8888/foo/dev" target="_blank" rel="noopener">http://localhost:8888/foo/dev</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;foo&quot;,&quot;profiles&quot;:[&quot;dev&quot;],&quot;label&quot;:&quot;master&quot;,</span><br><span class="line">&quot;version&quot;:&quot;792ffc77c03f4b138d28e89b576900ac5e01a44b&quot;,&quot;state&quot;:null,&quot;propertySources&quot;:[]&#125;</span><br></pre></td></tr></table></figure><p>证明配置服务中心可以从远程程序获取配置信息。</p><p>http请求地址和资源文件映射如下:</p><ul><li>/{application}/{profile}[/{label}]</li><li>/{application}-{profile}.yml</li><li>/{label}/{application}-{profile}.yml</li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties</li></ul><h3 id="构建一个config-client"><a href="#构建一个config-client" class="headerlink" title="构建一个config client"></a>构建一个config client</h3><p>重新创建一个springboot项目，取名为config-client,其pom文件：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.forezp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>config-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>service-ribbon<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.RELEASE<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-eureka --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-milestones<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Milestones<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>其配置文件：<br>spring.application.name=config-client<br>spring.cloud.config.label=master<br>spring.cloud.config.profile=dev<br>spring.cloud.config.uri= <a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a><br>server.port=8881</p><ul><li>spring.cloud.config.label 指明远程仓库的分支</li><li>spring.cloud.config.profile</li></ul><ol><li>dev开发环境配置文件</li><li>test测试环境</li><li>pro正式环境</li></ol><ul><li>spring.cloud.config.uri= <a href="http://localhost:8888/" target="_blank" rel="noopener">http://localhost:8888/</a> 指明配置服务中心的网址。<br>程序的入口类，写一个API接口“／hi”，返回从配置中心读取的foo变量的值，代码如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigClientApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConfigClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>写一个controller，controller代码如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiControler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;foo&#125;"</span>)</span><br><span class="line">    String foo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/hi"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> foo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打开网址访问：<a href="http://localhost:8881/hi，网页显示：" target="_blank" rel="noopener">http://localhost:8881/hi，网页显示：</a></p><p>foo version 3</p><p>这就说明，config-client从config-server获取了foo的属性，而config-server是从git仓库读取的,如图：</p><p><img src="http://blog.yangxiaozong.com/images/15520280871312279594-40ecbed6d38573d9.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇文章讲述zuul的时候，已经提到过，使用配置服务来保存各个服务的配置文件。它就是Spring Cloud Config。&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。&lt;/p&gt;
    
    </summary>
    
      <category term="Springcloud" scheme="http://www.yangxiaozong.com/categories/Springcloud/"/>
    
    
      <category term="Springcloud" scheme="http://www.yangxiaozong.com/tags/Springcloud/"/>
    
  </entry>
  
</feed>
